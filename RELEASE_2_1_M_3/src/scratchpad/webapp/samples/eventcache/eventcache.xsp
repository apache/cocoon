<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
    XSP event-based cache sample.

    $Id$
 -->


<xsp:page language="java"
          xmlns:xsp="http://apache.org/xsp"
          xmlns:xsp-request="http://apache.org/xsp/request/2.0">

<xsp:structure>
    <xsp:include>org.apache.excalibur.source.SourceValidity</xsp:include>
    <xsp:include>org.apache.cocoon.caching.validity.EventValidity</xsp:include>
    <xsp:include>org.apache.cocoon.caching.validity.NamedEvent</xsp:include>
    <xsp:include>java.io.Serializable</xsp:include>
</xsp:structure>

<xsp:logic>

    // artificial slowdown to make the effects of the cache visible
    final int DELAY_SECS = 2;

    /**
    * Generate the unique key for the cache.
    *
    * This key must be unique inside the space of this XSP page, it is used
    * to find the page contents in the cache (if getValidity says that the
    * contents are still valid).
    *
    * This method will be invoked before the getValidity() method.
    *
    * @return The generated key or null if the component
    *         is currently not cacheable.
    */
    public Serializable getKey()
    {
       // for our test, pages having the same value of "pageKey" will share
       // the same cache location
       return "" + request.getParameter("pageKey");
    }

    /**
    * Generate the validity object, tells the cache how long to
    * keep contents having this key around.  In this case, it will 
    * be until an Event is retrieved matching the NamedEvent created below.
    *
    * Before this method can be invoked the getKey() method
    * will be invoked.
    *
    * @return The generated validity object or null if the
    *         component is currently not cacheable.
    */
    public SourceValidity getValidity() {
       return new EventValidity(new NamedEvent(request.getParameter("pageKey")));
    }
 </xsp:logic>


  <page>
    <title>A Cacheable XSP Page (Demonstrating Event-Aware Caching)</title>
    <content>
    	<para>This xsp page is based on (copied from) the cacheable xsp sample 
    	but there are some important differences.  Read the text below, and the 
    	sitemap and source for more details.
    	</para>
        <para>
            Hi there! I'm a simple dynamic page generated by XSP (eXtensible Server Pages).  
            In order to use this sample property, you must have edited cocoon.roles and 
            specified the class for role org.apache.cocoon.caching.Cache is set to be 
            org.apache.cocoon.caching.impl.EventAwareCacheImpl.
        </para>

        <para>
            I need <xsp:expr>DELAY_SECS</xsp:expr> seconds to be generated, so you can tell
            if I'm being served from the cache or not.
            <br/>
            What you see here has been generated on <b><xsp:expr>new java.util.Date()</xsp:expr></b>.
        </para>

        <para>
            I'm cached for every different value of request parameter 'pageKey'.
            <br/>
            Here the value is:
            <b><xsp-request:get-parameter name="pageKey"/></b>.
            <br/>
            If this is not the same as the 'pageKey' parameter in the page URL, we have a problem.
        </para>

        <para>
          All other request parameters do not influence cache status.  
          Unlike other cacheable pages in Cocoon, I can be un-cached by events external 
          to Cocoon - for instance, when a database table or row is updated.
          <br/>
          My cache entry will be invalidated (actually, removed) when an event named 
          <i><xsp-request:get-parameter name="pageKey"/></i> occurs.  This can be manually 
          simulated by clicking 
          	<a><xsp:attribute name="href">?<xsp-request:get-query-string/>&amp;event=<xsp-request:get-parameter name="pageKey"/></xsp:attribute>here</a>.
        </para>
		<para>
			<b>NOTE: </b>Because the EventAwareCacheImpl has not yet implemented persistence for its 
			mappings, the event mappings will disappear but the cached keys will not.  Until this is 
			implemented you will want to clear both the in-memory and persistent store after using 
			this sample.  Once the mapping from the EventAwareCacheImpl is gone, firing the events 
			using the sample action <b>will not</b> clear those cached items.   
		</para>

        <xsp:logic>
          // slowdown page generation.
            try {
              Thread.sleep(DELAY_SECS * 1000L);
            } catch (InterruptedException ie) {
              // Not much that can be done...
            }
        </xsp:logic>

        <para>Test links:
            <ul>
                <li><a target="_new" href="?pageKey=one">pageKey=one</a></li>
                <li><a target="_new" href="?pageKey=two">pageKey=two</a></li>
                <li><a target="_new" href="?pageKey=three&amp;other=abc">pageKey=three, other=abc</a></li>
                <li><a target="_new" href="?pageKey=three&amp;other=xyz">pageKey=three, other=xyz</a></li>
            </ul>
        </para>
    </content>
  </page>
</xsp:page>