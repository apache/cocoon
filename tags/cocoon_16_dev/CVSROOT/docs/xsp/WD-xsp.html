<html>

<head>
<meta name="author" content="Stefano Mazzocchi">
<title>eXtensible Server Pages (XSP) Layer 1</title>
</head>

<body BGCOLOR="#FFFFFF">

<p><img src="../images/logo.gif" border="0"></p>

<h1 align="center">eXtensible Server Pages (XSP) Layer 1</h1>

<div align="center"><center>
<table border="0" width="60%" bgcolor="#000000" cellspacing="0" cellpadding="0">
  <tr>
    <td><table width="100%" border="0" cellspacing="2" cellpadding="4">
      <tr>
        <td bgcolor="#E0E0E0"><h3>Abstract</td>
      </tr>
      <tr>
        <td bgcolor="#ffffff">This document specifies an XML namespace that addresses a complete
        region of web publishing, that of logic-based, dynamic content generation. This language
        is introduced to fill an existing gap between the W3C specifications and working draft and
        the increasing demand for a flexible server side approach based on the new XML paradigm.</td>
      </tr>
      <tr>
        <td bgcolor="#E0E0E0"><h3>Status of this document</td>
      </tr>
      <tr>
        <td bgcolor="#ffffff">This is an Apache Working Draft for review by all interested
        parties. It is a draft document and may be updated, replaced, or obsoleted by other
        documents at any time. It is inappropriate to use Working Drafts as reference material or
        to cite them as other than &quot;work in progress&quot;. This work is part of the <a
        href="http://xml.apache.org/cocoon/index.html">Apache Cocoon Project</a></td>
      </tr>
      <tr>
        <td bgcolor="#E0E0E0"><h3>Version</td>
      </tr>
      <tr>
        <td bgcolor="#ffffff">Working Draft - 11091999</td>
      </tr>
      <tr>
        <td bgcolor="#E0E0E0"><h3>Author</td>
      </tr>
      <tr>
        <td bgcolor="#ffffff">Stefano Mazzocchi &lt;<a
        href="mailto:stefano@apache.org">stefano@apache.org</a>&gt;</td>
      </tr>
      <tr>
        <td bgcolor="#E0E0E0"><strong>Copyright &copy; 1999 Apache XML
        Project. All Rights Reserved.</strong></td>
      </tr>
    </table>
    </td>
  </tr>
</table>
</center></div>

<h2>1. Introduction</h2>

<blockquote>
  <p>This document specifies both an XML document type definition and a development
  methodology to generate dynamic XML by server side processing of client's requests. Such a
  specification is useful to define an open and standard way to develop and maintain dynamic
  XML server pages. The technology described in this document was designed to complete the
  XML-based publishing framework defined by the Cocoon Project and it's mainly targeted
  on
  this project, even if the final goal of this effort is to submit a request to a standard
  body (such as W3C) for final recommendation.</p>
</blockquote>

<h3>1.1 Origins</h3>

<blockquote>
  <p>The need for an open language to standardizing server side programmatic XML generation
  was observed when XML-based web publishing frameworks emerged and no available technology
  was detailed, stable, useful and open enough to be used. XSP, by mixing Turing-complete
  programming logic with page content, provide a flexible yet fully portable and extensible
  way to develop dynamic XML content. Moreover, being completely XML-based, XSP are fully
  integrated with XML-based web architectures that allow XSL-transformation to obtain the
  context separation that is needed for complex sites to increase their management
  parallelism.</p>
  <p>Being based on an XML paradigm from the beginning, XSP don't suffer limitations other
  server pages technologies do: the ability to XSL-transform XSP directly and recursively
  allows a more compact and precise DTD to be designed since content/logic/style separation
  is performed by the architecture and not by the language itself. For this reason, XSP are
  completely transparent to the namespaces/document-types used.</p>
</blockquote>

<h3>1.2 Layer Separation</h3>

<blockquote>
  <p>Being a rather complex technology, the XSP specification will be separated into layers.
  These layers will have different goals and restrictions and will allow faster development
  cycles and a better defined development model. Every layer will define its own document
  type definition which may extend the one of the previous layer or completely change it,
  depending on layer goals. Layers should be seen as levels of abstraction, much like
  programming languages range from higher-levels to lower-levels.</p>
</blockquote>

<h3>1.3 General Goals</h3>

<blockquote>
  <p>Following is a summary of the design principles governing the general XSP
  specification: <ol>
    <li>should integrate completely with existing W3C recommendations and working drafts</li>
    <li>should be programming language independent</li>
    <li>should be aimed to programmers but should be relatively easy to understand</li>
    <li>should allow pages to be compiled (into Java servlets or other equivalent technology)</li>
    <li>should not aim to replace existing technologies</li>
    <li>should be document oriented</li>
    <li>should allow easy reusability of page code</li>
    <li>should allow complete separation of knowledge contexts (content, logic and style)</li>
    <li>should be transparent to all but page programmers</li>
    <li>specification should be open to all but controlled directly by the Java Apache project</li>
  </ol>
</blockquote>

<h3>1.4 Layer 1 Goals</h3>

<blockquote>
  <p>Following is a summary of the design principles governing the Layer 1 of the XSP
  specification:<ol>
    <li>should define the complete element set</li>
    <li>should be aimed to machine generations so:&nbsp;&nbsp;&nbsp; <ul>
        <li>reducing the number of&nbsp; elements to a minimum is of maximal importance</li>
        <li>verbosity of the generated documents is of minimal importance</li>
      </ul>
    </li>
    <li>should be human readable/editable so:<ul>
        <li>terseness and readability are of maximal importance</li>
        <li>indenting and formattation are of maximal importance</li>
      </ul>
    </li>
    <li>should be possibly XSLT transformed directly into programming language source code</li>
    <li>should define the relations to the programming languages (object models, variable
      scopes)</li>
  </ol>
</blockquote>

<h3><strong>1.5 Layer 2 Goals</strong></h3>

<blockquote>
  <p>Following is a summary of the design principles governing the Layer 2 of the XSP
  specification:<ol>
    <li>should define a human oriented element set</li>
    <li>should be aimed to human generations so:&nbsp;&nbsp;&nbsp; <ul>
        <li>reducing the number of elements to a minimum is of minimal importance</li>
        <li>reducing verbosity of the documents is of maximal importance</li>
      </ul>
    </li>
    <li>should be aimed to medium-low knowledged programmers:<ul>
        <li>automatization of complex operations is of maximal importance</li>
        <li>tendency to hide page logic is of maximal importance</li>
      </ul>
    </li>
    <li>should be possibly XSLT transformed into XSP Layer 1 documents</li>
  </ol>
</blockquote>

<h3>1.6 Final Goals</h3>

<blockquote>
  <p>The XSP specification would eventually evolve into a single specification with a single
  document type definition. This will happen when the working draft phase will be terminated
  and all involved parties will agree on the specification stability. The Layer 1 will be
  the first to be developed and tested in a working implementation. Subsequent layers will
  probably need several evolution stages to reach their final shape.</p>
</blockquote>

<h3>1.7 Relationship to Existing Standards</h3>

<blockquote>
  <p>Three standards have been especially influential: <ul>
    <li><strong>JSP</strong> - Defines a way to embed programmatic logic into
      web documents.</li>
    <li><strong>XSLT</strong> - Defines a way to transform XML documents. </li>
    <li><strong>XML</strong> - Defines a flexible still highly structured paradigm for web
      content generation and distribution.</li>
  </ul>
  <p>Many server side dynamic web content generators have been evaluated and confronted,
  especially WebMacro and GSP.</p>
</blockquote>

<h3>1.8 Terminology</h3>

<blockquote>
  <p>The following basic terms apply in this document:<dl>
    <dt><b>document</b></dt>
    <dd>a document is the final result of the client request phase and they can be obtain from a
      single file that is read from disk/cache or by processing several ones. Documents are said
      <em>static</em> if their content doesn't change with user request parameters nor time.
      Documents are said <em>dynamic</em> if they do.</dd>
    <dt><strong>page</strong></dt>
    <dd>a page is the entity that is requested by the client and drives the document creation
      process. In the simplest case, a document is created reading the page and sending it
      directly without further processing. In case of compiled pages, a binary object is
      executed and it's content is used as page content. Pages are said <em>compiled </em>if
      they are translated into binary code. Note that compiled pages may be created from normal
      pages the first time the page is requested and executed as binary code in further requests
      for performance reasons.</dd>
    <dt><strong>sheet</strong></dt>
    <dd>a sheet is the processing unit of the document creation chain. Each sheet is a file and
      they contain the instructions to transform the requested page into the document sent to
      the requesting client. Sheets are said <em>style sheets</em> if they are the last of the
      chain and no further processing in performed, <em>logic sheets</em> if they contain XSP
      elements. Both types are said <em>transformation sheets</em> since they contain XSLT
      elements.</dd>
    <dt><strong>document type</strong></dt>
    <dd>a document type is a unique name that identifies the type of the document being
      generated. This term has the same meaning as in the XML specification. Note how a document
      has only one document type but this could change during processing since transformation
      sheets allow the transformation from one document type into another.</dd>
  </dl>
</blockquote>

<h2>2. XSP Syntax and DTD</h2>

<h3>2.1 Defined External Entities</h3>

<blockquote>
  <p>The XSP specification defines some external entities that may be used to reduce the
  verbosity of XSP document, allowing the inclusion the default DTD via entity mapping. The
  standard way to include the XSP DTD into XSP documents is:</p>
  <blockquote>
    <pre><font color="#0080FF">&lt;!DOCTYPE </font><font color="#FF0000">page</font><font
color="#0080FF"> PUBLIC </font><font
color="#0080FF">&quot;</font><font color="#FF0000">-//Apache//DTD XSP Layer 1//EN</font><font
color="#0080FF">&quot; &quot;</font><font color="#FF0000">http://www.apache.org/DTD/XSP/Layer1</font><font
color="#0080FF">&quot;&gt;</font></pre>
  </blockquote>
</blockquote>

<h3>2.2 The XSP Layer 1 Document Type Definition</h3>

<blockquote>
  <p>The XSP DTD was designed with simplicity in mind. The number of elements and attributes
  was reduced to a minimum to allow a fast and easy learning process. On the other hand, no
  special helper elements were defined in Layer 1 to reduce the spec development time and to
  favor early feedback from both implementers and users.</p>
  <p>The following is the complete DTD. It must be noted that this DTD can hardly be used
  (alone) to validate any XSP due to the fact that XSP are namespace orthogonal and are
  designed to include as content mark-up elements that belong to other namespaces.
  The XSchema effort will allow multi-namespace validation.&nbsp;</p>
</blockquote>

<blockquote>
  <blockquote>
    <pre><font color="#0080FF">&lt;!ELEMENT </font><font color="#FF0000">xsp:page</font><font
color="#0080FF"> (</font><font color="#FF0000">xsp:structure</font><font color="#0080FF">?, </font><font
color="#FF0000">xsp:logic</font><font color="#0080FF">?, </font><font color="#FF0000">xsp:content</font><font
color="#0080FF">)&gt;
&lt;!ATTLIST </font><font color="#FF0000">xsp:page
  language</font><font
color="#0080FF"> CDATA #REQUIRED
  </font><font color="#FF0000">result-ns</font><font
color="#0080FF"> NMTOKEN #IMPLIED
  </font><font color="#FF0000">default-space</font><font
color="#0080FF"> (preserve|strip) &quot;preserve&quot;
  </font><font color="#FF0000">indent-result</font><font
color="#0080FF"> (yes|no) &quot;no&quot;
  </font><font color="#FF0000">xmlns:xsp</font><font
color="#0080FF"> CDATA #FIXED &quot;</font><font color="#FF0000">http://www.apache.org/DTD/XSP/Layer1</font><font
color="#0080FF">&quot;
  </font><font
color="#FF0000">xml:space</font><font color="#0080FF"> (default|preserve) &quot;preserve&quot;
&gt;

&lt;!ELEMENT </font><font
color="#FF0000">xsp:structure</font><font color="#0080FF"> (</font><font color="#FF0000">xsp:dtd</font><font
color="#0080FF">?, </font><font color="#FF0000">xsp:include</font><font color="#0080FF">*)&gt;

&lt;!ELEMENT </font><font
color="#FF0000">xsp:dtd</font><font color="#0080FF"> (#PCDATA)&gt;
&lt;!ELEMENT </font><font
color="#FF0000">xsp:include</font><font color="#0080FF"> (#PCDATA)&gt;

&lt;!ELEMENT </font><font color="#FF0000">xsp:content</font><font
color="#0080FF">
	(#PCDATA | 
	</font><font color="#FF0000">xsp:logic</font><font
color="#0080FF"> | 
	</font><font color="#FF0000">xsp:element</font><font color="#0080FF"> | 
	</font><font
color="#FF0000">xsp:eval</font><font color="#0080FF"> | 
	</font><font color="#FF0000">xsp:pi</font><font
color="#0080FF"> | 
	</font><font color="#FF0000">xsp:comment</font><font color="#0080FF">)*
&gt;

&lt;!ELEMENT </font><font
color="#FF0000">xsp:logic</font><font color="#0080FF">
	(#PCDATA | 
	</font><font
color="#FF0000">xsp:eval</font><font color="#0080FF"> | 
	</font><font color="#FF0000">xsp:content</font><font
color="#0080FF"> | 
	</font><font color="#FF0000">xsp:element</font><font color="#0080FF"> | 
	</font><font
color="#FF0000">xsp:comment</font><font color="#0080FF"> | 
	</font><font color="#FF0000">xsp:pi</font><font
color="#0080FF">)*
&gt;
&lt;!ATTLIST </font><font color="#FF0000">xsp:logic
  xml:space</font><font
color="#0080FF"> (default|preserve) &quot;preserve&quot;</font>
<font color="#0080FF">&gt;

&lt;!ELEMENT </font><font
color="#FF0000">xsp:element</font><font color="#0080FF">
	(#PCDATA | 
	</font><font
color="#FF0000">xsp:attribute</font><font color="#0080FF"> | 
	</font><font color="#FF0000">xsp:element</font><font
color="#0080FF"> | 
	</font><font color="#FF0000">xsp:logic</font><font color="#0080FF">)*
&gt;
&lt;!ATTLIST </font><font
color="#FF0000">xsp:element</font>
<font color="#0080FF">  </font><font color="#FF0000">name</font><font
color="#0080FF"> CDATA #REQUIRED
&gt;

&lt;!ELEMENT </font><font color="#FF0000">xsp:attribute</font><font
color="#0080FF"> (#PCDATA)&gt;
&lt;!ATTLIST </font><font color="#FF0000">xsp:attribute</font><font
color="#0080FF"> </font>
<font color="#FF0000">  name</font><font color="#0080FF"> CDATA #REQUIRED
  </font><font
color="#FF0000">xml:space</font><font color="#0080FF"> (default|preserve) &quot;preserve&quot;
&gt;
</font>
<font
color="#0080FF">&lt;!ELEMENT </font><font color="#FF0000">xsp:pi</font><font color="#0080FF"> (#PCDATA | </font><font
color="#FF0000">xsp:eval</font><font color="#0080FF">&gt;
&lt;!ELEMENT </font><font
color="#FF0000">xsp:comment</font><font color="#0080FF"> (#PCDATA | </font><font
color="#FF0000">xsp:eval</font><font color="#0080FF">)&gt;
&lt;!ELEMENT </font><font
color="#FF0000">xsp:expr</font><font color="#0080FF"> (#PCDATA)&gt;</font></pre>
  </blockquote>
</blockquote>

<h2>3. Example of Usage</h2>

<blockquote>
  <p>Consider the following XML source document: </p>
</blockquote>

<blockquote>
  <blockquote>
    <font COLOR="blue"><pre>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;page&gt;
 &lt;title&gt;A Simple XSP Page&lt;/title&gt;
 &lt;p&gt;Hi, I've been hit <font
color="red">&lt;counter/&gt;</font> times.&lt;/p&gt;
&lt;/page&gt;</pre>
    </font>
  </blockquote>
</blockquote>

<blockquote>
  <p>This simple example shows the power of content/logic/style separation. While the <code>&lt;title&gt;</code>
  tag has a very special meaning in the <em>page</em> document type, indicating the page
  title, the <code>&lt;counter&gt;</code> element is needs to be dynamically substituted by
  the number of times the document has been requested. The logic that performs such behavior
  is included in tag itself, but unlike other existing server side technologies, the
  behavior is not defined in the page itself, but on the logic sheet that is applied to
  evaluate this behavior. In fact, the same page may have a totally different behavior
  depending on the logicsheet that is applied to the page. Note that it's beyond the scope
  of this specification to define a way to associate transformation sheets to pages. The
  associated logicsheet that uses the Java language as logic definition may look like: </p>
  <blockquote>
    <pre><font COLOR="blue">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xsl:transformation 
 xmlns:xsl=&quot;http://www.w3.org/TR/WD-xsl&quot; 
 xmlns:xsp=&quot;</font><font color="#FF0000">http://www.apache.org/DTD/XSP/Layer1</font><font COLOR="blue">&quot;
 result-ns=&quot;</font><font color="#FF0000">http://www.apache.org/DTD/XSP/Layer1</font><font COLOR="blue">&quot;
&gt;
   
 &lt;xsl:template match=&quot;page&quot;&gt;
  &lt;xsp:page language=&quot;java&quot;&gt;

   &lt;xsp:structure&gt;
    &lt;xsp:include&gt;</font><font
color="#FF0000">java.lang.*</font><font COLOR="blue">&lt;/xsp:include&gt;
   &lt;/xsp:structure&gt;
     
   &lt;xsp:logic&gt;
    </font><font
color="red">private static int counter = 0;
         
    private synchronized int currentCount() {
      return ++counter;
    }</font><font
COLOR="blue">
   &lt;/xsp:logic&gt;
      
   &lt;xsp:content&gt;
    &lt;page&gt;
     &lt;xsl:apply-templates/&gt;
    &lt;/page&gt;
   &lt;/xsp:content&gt;
  &lt;/xsp:page&gt;
 &lt;/xsl:template&gt;
    
 &lt;xsl:template match=&quot;counter&quot;&gt;    
  &lt;xsp:expr&gt;</font><font
color="red">currentCount()</font><font COLOR="blue">&lt;/xsp:expr&gt;
 &lt;/xsl:template&gt;

 &lt;!-- Transcribe everything else verbatim --&gt;
 &lt;xsl:template match=&quot;*|@*|comment()|pi()|text()&quot;&gt;
  &lt;xsl:copy&gt;
   &lt;xsl:apply-templates/&gt;
  &lt;/xsl:copy&gt;
 &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</font></pre>
  </blockquote>
  <p>After applying the above logic sheet, the resulting document would be equivalent to the
  following: </p>
  <blockquote>
   <pre><font COLOR="blue">&lt;xsp:page 
 result-ns=&quot;http://www.dummy.org/SimpleHomepageDTD&quot;
 language=&quot;java&quot;&gt;

 &lt;xsp:structure&gt;
  &lt;xsp:include&gt;</font><font
color="#FF0000">java.lang.*</font><font COLOR="blue">&lt;/xsp:include&gt;
 &lt;/xsp:structure&gt;

 &lt;xsp:logic&gt;<font
color="red">
  private static int counter = 0;
        
  private synchronized int currentCount() {
    return ++counter;
  }</font>
 &lt;/xsp:logic&gt;

 &lt;xsp:content&gt;
  &lt;page&gt;
   &lt;title&gt;A Sample XSP Page&lt;/title&gt;
   &lt;p&gt;Hi, I've been hit &lt;xsp:expr&gt;<font
color="red">currentCount()</font>&lt;/xsp:expr&gt; times.&lt;/p&gt;
  &lt;/page&gt;
 &lt;/xsp:content&gt;
&lt;/xsp:page&gt;</font>   </pre>
  </blockquote>
  <p>At this point it's worth to note that from an XSP point of view, there is no difference
  in how the XSP page was created, either directly written or created with n levels of
  transformation. So, independently of whether an XSL stylesheet or a special algorithm was
  used to generate the final source code, it may look like this [Note: many key issues regarding
  servlets were omitted for simplicity and this example must not be considered mandating as
  a way to format XSP into servlet source code] </p>
  <blockquote>
    <font COLOR="blue"><pre>// package automatically created from the full request URL...
package org.apache.cocoon.xsp.example;</pre>
    </font><pre><font COLOR="blue">// packages imported automatically by source code generator
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
import org.w3c.dom.*;
  
// packages imported due to XSP structure
import </font><font
color="#FF0000">java.lang.*</font><font COLOR="blue">;

// class name automatically created from the request URI file name...
public class Counter extends HttpServlet {

  public void init(ServletConfig config) throws ServletException {
    super.init(config);
  }

</font><font
color="red">  private static int counter = 0;
            
  private synchronized int currentCount() {
    return ++counter;
  }</font><font
COLOR="blue">
 
  public void service(HttpServletRequest request, HttpServletResponse response) throws IOException {
    Document document = parser.createEmptyDocument();
    Element root = document.createElement(<font
color="darkGreen">&quot;page&quot;</font>);
    document.appendChild(root);
  
    Element element_1 = document.createElement(<font
color="darkGreen">&quot;title&quot;</font>);
    root.appendChild(element_1);
    Text textNode_1 = document.createTextNode(<font
color="darkGreen">&quot;A Sample XSP Page&quot;</font>);
    element_1.appendChild(textNode_1);

    Element element_2 = document.createElement(<font
color="darkGreen">&quot;p&quot;</font>);
    root.appendChild(element_2);
    Text textNode_2 = document.createTextNode(&quot;</font><font
color="darkGreen">Hi, I've been hit &quot;</font><font color="blue">);
    element_2.appendChild(textNode_2);
    Text textNode_3 = document.createTextNode((new StringBuffer.append(<font
color="red">currentCount()</font>)).toString());
    element_2.appendChild(textNode_3);
    Text textNode_4 = document.createTextNode(<font
color="darkGreen">&quot;times.&quot;</font>);
    element_2.appendChild(textNode_4);
  
    // Produce generated DOM tree on output as an XML stream
    ((Child) document).toXMLString(response.getWriter());
  }
}</font></pre>
  </blockquote>
  <p>Note that in this example the XML document is being generated as a <i>stream</i>
  but a DOM tree is used to create it. The DOM tree can't be passed directly to
  the servlet engine for further processing because the current servlet specification
  (2.2) does not allow
  for content generation in a format other than a stream. A rather undesirable consequence
  of this is that the resulting XML document would need to be re-parsed in case a final XSL
  stylesheet or other post-transformation must be applied. </p>
  <p>To solve this problem and speed up the execution on server side XML
  processing, the XSP can be compiled into something like this: </p>
    <font COLOR="blue">
    <blockquote>
      <pre>// package automatically created from the full request URL...
package org.apache.cocoon.xsp.example;</pre>
    </font><pre><font COLOR="blue">// packages imported automatically by source code generator
import java.io.*;
import java.util.*;
import org.xml.sax.*;
import org.apache.cocoon.*;</font><font COLOR="blue">
  
// packages imported due to XSP structure
import </font><font
color="#FF0000">java.lang.*</font><font COLOR="blue">;

// class name automatically created from the request URI file name...
public class Counter extends AbstractProducer {

</font>  <font color="blue">private static final</font> <font
COLOR="blue">char[] chars_0 = {'</font><font color="darkGreen">A</font><font
COLOR="blue">',' ','</font><font color="darkGreen">S</font><font
COLOR="blue">','</font><font color="#006400">i</font><font
COLOR="blue">','</font><font color="#006400">m</font><font
COLOR="blue">','</font><font color="#006400">p</font><font
COLOR="blue">','</font><font color="#006400">l</font><font
COLOR="blue">','</font><font color="#006400">e</font><font
COLOR="blue">',' ','</font><font color="#006400">X</font><font
COLOR="blue">','</font><font color="#006400">S</font><font
COLOR="blue">','</font><font color="#006400">P</font><font
COLOR="blue">',' ','</font><font color="#006400">P</font><font
COLOR="blue">','</font><font color="#006400">a</font><font
COLOR="blue">','</font><font color="#006400">g</font><font
COLOR="blue">','</font><font color="#006400">e</font><font
COLOR="blue">'};
</font><font
COLOR="blue">  private static final char[] chars_1 = {'</font><font color="darkGreen">H</font><font
COLOR="blue">','</font><font color="#006400">i</font><font
COLOR="blue">',' ','</font><font color="#006400">I</font><font
COLOR="blue">','</font><font color="#006400">\'</font><font
COLOR="blue">','</font><font color="#006400">v</font><font
COLOR="blue">','</font><font color="#006400">e</font><font
COLOR="blue">','</font><font color="#006400"> </font><font
COLOR="blue">','</font><font color="#006400">b</font><font
COLOR="blue">','</font><font color="#006400">e</font><font
COLOR="blue">','</font><font color="#006400">e</font><font
COLOR="blue">','</font><font color="#006400">n</font><font
COLOR="blue">','</font><font color="#006400"> </font><font
COLOR="blue">','</font><font color="#006400">h</font><font
COLOR="blue">','</font><font color="#006400">i</font><font
COLOR="blue">','</font><font color="#006400">t</font><font
COLOR="blue">',' '};
  private static final char[] chars_3 = {' ','</font><font color="darkGreen">t</font><font
COLOR="blue">','</font><font color="#006400">i</font><font
COLOR="blue">','</font><font color="#006400">m</font><font
COLOR="blue">','</font><font color="#006400">e</font><font
COLOR="blue">','</font><font color="#006400">s</font><font
COLOR="blue">'};

</font><font
color="red">  private static int counter = 0;
            
  private synchronized int currentCount() {
    return ++counter;
  }</font><font
COLOR="blue">
 
  public void toSAX(Request request, DocumentHandler handler) throws SAXException {
    handler.startDocument();
      handler.startElement(<font
color="darkGreen">&quot;page&quot;</font></font><font color="blue">, null</font><font
COLOR="blue">);
        handler.startElement(<font
color="darkGreen">&quot;title&quot;</font></font><font color="blue">, null</font><font
COLOR="blue">);
          handler.characters(chars_0, 0, 17);
        handler.endElement(<font
color="darkGreen">&quot;title&quot;</font>);
        handler.startElement(<font
color="darkGreen">&quot;p&quot;</font></font><font color="blue">, null</font><font
COLOR="blue">);
          handler.characters(chars_1, 0, 17);
          String string_0 = new StringBuffer.append(<font
color="red">currentCount()</font>)).toString();
          int string_0_length = string_0.length();
          char[] chars_2 = char[string_0_length];
          string_0.getChars(0, string_0_length, chars_2, 0);
          handler.characters(chars_3, 0, 6);
        handler.endElement(<font
color="darkGreen">&quot;p&quot;</font>);
      handler.endElement(<font
color="darkGreen">&quot;page&quot;</font>);
    handler.endDocument();
  }
}</font></pre>
  </blockquote>
  <p>The above shows one of the great features of XSP: output independence.
  Since the output objects are not accessible directly from the internal page
  logic (unlike other similar technologies, such as JSP), the page compiler can
  choose between a great variety of possible ways to generate and forward the
  page content. In fact, while the first example uses DOM as a construction set
  and a stream as output method, the exact same page is compiled in the second
  example to use a SAX event-based model and a document handler as output. </p>
  <p>Finally, It is beyond the scope of this specification to define how XSP are translated
  into binary code and how these interact with the publishing frameworks that handle
  them, but it is mandated that this should be completely transparent to the
  page programmer and an XSP page should behave exactly the same (modulo
  performance) in every XSP engine. </p>
</blockquote>

<h2>4. XSP and JSP </h2>
<blockquote>
  <p>XSP and JSP might appear as overlapping at a first glance since they both </p>
  <ul>
    <li>follow the <i>compiled server pages</i> model, allowing server pages to
      be compiled into binary code for faster execution.</li>
    <li>can be parsed and validated by regular XML parsers</li>
    <li>can be transformed by XSLT processors</li>
    <li>aim to programming language abstraction</li>
  </ul>
  <p>While these are very important points were the two specifications <i>do</i>
  overlap, there are significant differences described hereafter.</p>
</blockquote>
<h3>4.1 Output Exposure</h3>
<blockquote>
  <p>In all different server pages technologies, some data regarding the status
  of the resource are available to page logic. Since JSP follow the Servlet API
  model, expecting JSP pages to be compiled into servlets, the same data
  available to servlet is available to page logic. This allows the page logic to
  obtain access to the output channel (being either an OutputStream or a Writer
  for servlets).</p>
  <p>While this is not a problem for normal web operation when no further server
  side processing is performed, for XML generation (where further server side
  processing may be needed, depending on client capabilities) the Servlet/JSP
  limitations impose on the server pages engine a parsing stage that is
  completely avoided in XSP.</p>
  <p>In fact, in XSP, page logic has <i>not</i> direct access to the output
  channel and it's the page compiler responsibility to choose the preferred
  method to compile the page, depending on processing needs and server
  requirements.&nbsp;</p>
  <p>It should be noted how XSP spec provides three different contexts: <code>content</code>,
  <code>logic</code> and <code>eval</code>. These three contexts never overlap
  since <code>content</code> is used to create static markup content, <code>logic</code>
  to indicate programming logic and <code>eval</code> to bridge the two domains,
  allowing a logic component to be evaluated without exposing the output channel
  to the logic context.</p>
  <p>This is a very significant difference since it allows XSP page compiler to <i>hardcode</i>
  pre-parsed XML content thus removing the request time parsing overhead that
  JSP always require.</p>
</blockquote>
<h3>4.2 Page Readability</h3>
<blockquote>
  <p>For these reasons, XSP, unlike JSP, uses the XML feature of <i>syntax
  orthogonalily</i> that allows almost any programming language code to be
  easily distinguishable between markup elements, while JSP needs to enclose
  programming code by <i>scriptlet</i> tags. The following is an example to show
  the different results based on the same logic and code.&nbsp;</p>
  <blockquote>
    <pre><font color="#0000FF">&lt;xsp:logic&gt;&lt;![CDATA[
</font><font color="#FF0000">   e = request.getParameterNames(); 
   if ((e != null) &amp;&amp; (e.hasMoreElements())) { </font><font color="#0000FF">]]&gt;</font><font color="#FF0000">
</font><font color="#0000FF">      &lt;xsl:content&gt;
</font><font color="#006400">        &lt;list&gt;
          &lt;title&gt;Servlet Parameters&lt;/title&gt;
</font><font color="#0000FF">          &lt;xsp:logic&gt;&lt;![CDATA[
</font><font color="#FF0000">             while (e.hasMoreElements()) { 
                String k = (String) e.nextElement();
                String val = request.getParameter(k); 
                String vals[] = request.getParameterValues(k);</font><font color="#0000FF"> ]]&gt;</font><font color="#FF0000">
</font><font color="#0000FF">                &lt;xsp:element name=&quot;element&quot;&gt;
                   &lt;xsp:attribute name=&quot;name&quot;&gt;
                      &lt;xsp:expr&gt;</font><font color="#FF0000">k</font><font color="#0000FF">&lt;/xsp:expr&gt;
                   &lt;/xsp:attribute&gt;
                   &lt;xsp:logic&gt;&lt;![CDATA[
                      </font><font color="#FF0000">for(int i = 0; i &lt; vals.length; i++)</font><font color="#0000FF"> { ]]&gt;
                         &lt;item&gt;
                            &lt;xsp:expr&gt;</font><font color="#FF0000">vals[i]</font><font color="#0000FF">&lt;/xsp:expr&gt;
                         &lt;/item&gt;
                      </font><font color="#FF0000">}</font><font color="#0000FF">
                   &lt;/xsp:logic&gt;
                &lt;/xsp:element&gt;
              </font><font color="#FF0000">}</font><font color="#0000FF">
           &lt;/xsp:logic&gt;
</font><font color="#006400">        &lt;/list&gt;
</font><font color="#0000FF">      &lt;/xsl:content&gt;
    </font><font color="#FF0000">} </font><font color="#0000FF">
 &lt;/xsp:logic&gt;</font></pre>
  </blockquote>
  <p>This is the JSP equivalent:</p>
  <blockquote>
    <pre><font color="#0000FF">&lt;jsp:scriplet&gt;&lt;![CDATA[
</font><font color="#FF0000">e = request.getParameterNames(); 
if ((e != null) &amp;&amp; (e.hasMoreElements())) {</font><font color="#0000FF"> ]]&gt; &lt;/jsp:scriplet&gt;
  </font><font color="#008000">&lt;list&gt;
  &lt;title&gt;Servlet Parameters&lt;/title&gt;</font><font color="#0000FF">
    &lt;jsp:scriplet&gt;&lt;![CDATA[
    </font><font color="#FF0000">while (e.hasMoreElements()) { 
      String k = (String) e.nextElement();
      String val = request.getParameter(k); 
      String vals[] = request.getParameterValues(k);
      out.println(&quot;</font><font color="#008000">&lt;element name=\&quot;name\&quot;&gt;</font><font color="#FF0000">&quot;);</font><font color="#0000FF"> ]]&gt; &lt;/jsp:scriplet&gt;
      &lt;jsp:expression&gt;</font><font color="#FF0000">k</font><font color="#0000FF">&lt;/jsp:expression&gt;
      &lt;jsp:scriplet&gt;&lt;![CDATA[
      </font><font color="#FF0000">out.println(&quot;</font><font color="#008000">&lt;/element&gt;</font><font color="#FF0000">&quot;);
      for(int i = 0; i &lt; vals.length; i++) {</font><font color="#0000FF"> ]]&gt; &lt;/jsp:scriplet&gt;
        &lt;item&gt;
          &lt;jsp:expression&gt;</font><font color="#FF0000">vals[i]</font><font color="#0000FF">&lt;/jsp:expression&gt;
        &lt;/item&gt;
      &lt;jsp:scriplet&gt;</font><font color="#FF0000">}</font><font color="#0000FF">&lt;/jsp:scriplet&gt;
    &lt;jsp:scriplet&gt;</font><font color="#FF0000">}</font><font color="#0000FF">&lt;/jsp:scriplet&gt;
  </font><font color="#008000">&lt;/list&gt;</font><font color="#0000FF">
&lt;jsp:scriplet&gt;</font><font color="#FF0000">}</font><font color="#0000FF">&lt;/jsp:scriplet&gt;</font></pre>
  </blockquote>
  <p>It must be noted the use of the <i>out</i> object in the JSP example while
  XSP provide specific tags to avoid that.</p>
</blockquote>

<hr>

<h1>Appendices</h1>

<h2>A. Normative References</h2>

<dl>
  <dt><b>[DOM]</b></dt>
  <dd>&quot;Document Object Model (DOM) Level 1 Specification&quot;, Lauren Wood <i>et al.</i>,
    1 October 1998.<br />
    Available at: <a href="http://www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</a></dd>
  <dt><b>[RFC2119]</b></dt>
  <dd>&quot;RFC2119: Key words for use in RFCs to Indicate Requirement Levels&quot;, S.
    Bradner, March 1997.<br />
    Available at: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a></dd>
  <dt><b>[RFC2376]</b></dt>
  <dd>&quot;RFC2376: XML Media Types&quot;, E. Whitehead, M. Murata, July 1998.<br />
    Available at: <a href="http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</a></dd>
  <dt><b>[RFC2396]</b></dt>
  <dd>&quot;RFC2396: Uniform Resource Identifiers (URI): Generic Syntax&quot;, T. Berners-Lee,
    R. Fielding, L. Masinter, August 1998.<br />
    This document updates RFC1738 and RFC1808.<br />
    Available at: <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a></dd>
  <dt><b>[XML]</b></dt>
  <dd>&quot;Extensible Markup Language (XML) 1.0 Specification&quot;, T. Bray, J. Paoli, C. M.
    Sperberg-McQueen, 10 February 1998.<br />
    Available at: <a href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a></dd>
  <dt><b>[XMLNAMES]</b></dt>
  <dd>&quot;Namespaces in XML&quot;, T. Bray, D. Hollander, A. Layman, 14 January 1999.<br />
    XML namespaces provide a simple method for qualifying names used in XML documents by
    associating them with namespaces identified by URI.<br />
    Available at: <a href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</a></dd>
  <dt><b>[XSLT]</b></dt>
  <dd>Working Draft &quot;XSL Transformations (XSLT) Specification Version 1.0&quot;, J.
    Clark, 21 April 1999<br />
    Available at: <a href="http://www.w3.org/TR/WD-xslt">http://www.w3.org/TR/WD-xslt</a></dd>
  <dt><b>[SAX]</b></dt>
  <dd> &quot;The Simple API for XML (Java implementation) version 1.0&quot;,D.
    Megginson<br />
    Available at: <a href="http://www.w3.org/TR/WD-xslt">http://www.megginson.com/SAX/</a></dd>
</dl>

<h2>B. Acknowledgements</h2>

<blockquote>
  <p>The following have contributed to authoring this draft:</p>
  <blockquote>
    <p>Ricardo Rocha &lt;<a href="mailto:rrocha@plenix.org">rrocha@plenix.org</a>&gt;</p>
  </blockquote>
</blockquote>
</body>
</html>

