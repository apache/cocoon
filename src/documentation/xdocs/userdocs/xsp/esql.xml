<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 1999-2004 The Apache Software Foundation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.0//EN" "../../dtd/document-v10.dtd">

<document><header><title>ESQL Taglib</title>
<authors>
<person name="Donald A. Ball Jr." email="balld@webslingerz.com"/>
<person name="Robin Green" email="greenrd@hotmail.com"/>
</authors></header><body>

    <s1 title="Description">

    <p>The ESQL logicsheet is an XSP logicsheet that performs sql queries and
    serializes their results as XML. This allows you to work with data from a
    wide variety of different sources when using Apache Cocoon.
   </p>

   <p>It has a number of important advantages over the old (deprecated) SQL
    logicsheet and SQL processor. For example, it allows you to mix esql with
    other logicsheets. It also supports prepared statements (which gives you
    automatic parameter escaping), multiple encodings in a single query and
    even multiple resultsets on one statement (if supported from database)!</p>

    <p>The name was chosen merely to emphasise the fact that this is an
    extended version of the old sql logicsheet - esql still uses standard SQL
    syntax. In fact, it is just a conversion wrapper around your JDBC database
    driver, so it supports no more and no less SQL syntax than your JDBC driver
    supports.
    </p>
  </s1>

  <s1 title="Installation">
   <p>Check your <code>cocoon.xconf</code> for this line and add it if it's not already there:</p>
   <source><![CDATA[
<builtin-logicsheet>
  <parameter name="prefix" value="esql"/>
  <parameter name="uri" value="http://apache.org/cocoon/SQL/v2"/>
  <parameter name="href"
  value="resource://org/apache/cocoon/components/language/markup/xsp/java/esql.xsl"/>
</builtin-logicsheet>
]]></source>
  </s1>

  <s1 title="Configuration">
   <p>Map the</p>
   <source>http://apache.org/cocoon/SQL/v2</source>
   <p>namespace to the esql prefix. Elements in the esql taglib namespace will be interpreted as input to 
    the esql taglib and will be stripped from the output.</p>
   <p>This is typically done like this:</p>
   <source><![CDATA[
<xsp:page
      language="java"
      xmlns:xsp="http://apache.org/xsp"
      xmlns:esql="http://apache.org/cocoon/SQL/v2"
>
. . .
</xsp:page>
]]></source>
	  
   <s2 title="Connection">
	<p>Esql can use connection pools configured in <code>cocoon.xconf</code> or
	 individually set up connections.</p>
	
	<p><code>esql:pool</code> gives the name of the connection pool to use.</p>

	<p>Individually configured connections use the <code>esql:driver,
	  esql:dburl, esql:username, esql:password</code> tags. Their meaning
	 should be obvious.</p>

	<s3 title="Connection Options"/>
	<p>Per default, esql will try to switch a connection to <em>autocommit</em>
	 mode. This is because it prevents hanging transactions that hold locks and
	 disturb further database accesses. Esql can be forced to not use
	 autocommit, by giving the
	 <code>&lt;esql:autocommit&gt;false&lt;/esql:autocommit&gt;</code> nested
	 element to <code>esql:connection</code>.</p>

	<note>Even if a connection is configured with autocommit off in
	 <code>cocoon.xconf</code>, esql will switch autocommit on if not
	 instructed to do otherwise.</note>

	<p>Other options like limiting the size of the resultset are discussed
	 below.</p>
   </s2>

  </s1>

  <s1 title="Usage and Examples">
   <p>At the moment documentation on esql is quite thin on the ground -
    however, it should be enough to get you started. In the
    <code>docs/samples/xsp</code> directory you will find
    <code>esql.xsp</code>, which is an example of two esql queries,
    demonstrating "nested" queries and dynamic prepared statements. However,
    much more comprehensive is the <strong>schema</strong> in
    <code>esql.xsd</code> which is a formal specification, written in the W3C
    standard language XML Schema, of every single esql element and attribute.
    It is fairly human-readable and includes comments for the purpose of each
    tag.</p>

   <p>A fairly common example is to list a query result in a table. Notice that
    esql:results and esql:no-results are mutual exclusive. So only one of them
    will be in your XML tree. This example takes a connection from a datasource
    defined in <code>cocoon.xconf</code>:</p>

   <source><![CDATA[
<esql:connection>
  <esql:pool>connectionName</esql:pool>
  <esql:execute-query>
    <esql:query>SELECT mycolumn1,mycolumn2 FROM table</esql:query>
    <esql:results>
      <table>
        <esql:row-results>
          <tr>
             <td><esql:get-string column="mycolumn1"/></td>
             <td><esql:get-string column="mycolumn2"/></td>
          </tr>
        </esql:row-results>
      </table>
    </esql:results>
    <esql:no-results>
       <p>Sorry, no results!</p>
    </esql:no-results>
  </esql:execute-query>
</esql:connection>]]>
</source>

   <s2 title="Dynamic Queries">
    <p>When a query contains dynamic parts, e.g. a value that is to be matched,
     esql offers two different possibilities to achieve that. First, as the 
     query is really a string, it can be constructed like any other string by 
     concattenation.
    </p>

   <source><![CDATA[
    <xsp:logic>
       String orderBy = null;
       switch(type) {
       case 1: orderBy = "order by name"; break;
       case 2: orderBy = "order by salary"; break;
       default: orderBy = "";
       }
    </xsp:logic>

    <!-- ... -->

    <esql:query><xsp:expr>"SELECT name, salary FROM employee "+orderBy</xsp:expr></esql:query>
]]>
</source>

    <p>Note, however, that here any string will be part of the actual
     statement. In this example it does no harm as the value for the
     <code>orderBy</code> variable is completely under the control of
     your code. Any malicious attacker could not inject his or her own
     code. Thus this technique should not be used when values returned
     from the client have to be used.
    </p>
    <p>The second variant is to use a PreparedStatement for dynamic 
     parameters. Since the driver is supposed to keep parameters
     distinct from the statement, no code can be injected this way. In
     addition, your DBMS puts more effort into optimizing the
     statement. PreparedStatements are created whenever a
     <code>&lt;esql:parameter/&gt;</code> tag appears in a query. 
    </p>
   <source><![CDATA[
    <esql:query>SELECT name, salary FROM employee 
                WHERE name=<esql:parameter><xsp:expr>name</xsp:expr></esql:parameter></esql:query>
]]>
   </source>
   </s2>

   <s2 title="Refering to Results">

    <p>A select query usually returns one ResultSet. This case is handled by
     the <code>esql:results</code> tag and its content. However, many special
     cases exist, e.g. an error occurs or an update query is used. Esql
     provides different tags for these cases.
    </p>

    <p>If an empty result set is returned, the <code>esql:no-results</code>
     block is used.</p>

    <s3 title="Errors">
     <p>In case of an error, usually signalled by an Exception during setup or
      execution of a query, the <code>esql:error-results</code> block is
      evaluated. If no such tag exists, the exception is rethrown and
      processing is stopped. Withing the tag, <code>esql:get-message</code>,
      <code>esql:get-stacktrace</code>, and <code>esql:to-string</code> allow
      access to the error message.</p>
    </s3>

    <s3 title="Limiting the number of rows returned">

     <p>Esql allows to display only a part of the result set using the
      <code>esql:use-limit-clause</code>. If your DBMS is supported, the DBMS
      generates only the indicated rows, otherwise a number of rows are skipped
      and retrieval is stopped after a given number of rows. It works like a
      fixed-size window to the result set, paging through it.</p>

     <p>These parameters are set for a connection.</p>

     <p>If the <code>esql:use-limit-clause</code> is empty or set to "auto",
      esql tries to determine automatically which method to use, depending on
      the connection URL.</p> 

     <p><code>esql:skip-rows</code> and <code>esql:max-rows</code> tags specify
      how many rows should be skipped at the beginning and how many rows should
      be retrieved at maximum.</p>

     <p>In this context the <code>esql:previous-results</code> and
      <code>esql:more-results</code> blocks hold code and content that is only
      used if this sliding window has previous or following windows.</p>

   </s3>

   <source><![CDATA[
<esql:connection>
  <esql:pool>connectionName</esql:pool>
  <esql:execute-query>
    <esql:query>SELECT mycolumn1,mycolumn2 FROM table</esql:query>
    <esql:use-limit-clause>auto</esql:use-limit-clause>
    <esql:skip-rows><xsp:expr>skiprows</xsp:expr></esql:skip-rows>
    <esql:max-rows>10</esql:max-rows>
    <esql:results>
      <table>
        <esql:row-results>
        <esql:previous-results>previous rows available</esql:previous-results>
        <esql:more-results>more rows available</esql:more-results>
          <tr>
             <td><esql:get-string column="mycolumn1"/></td>
             <td><esql:get-string column="mycolumn2"/></td>
          </tr>
        </esql:row-results>
      </table>
    </esql:results>
    <esql:error-results>An error occurred</esql:error-results>
    <esql:no-results>
       <p>Sorry, no results!</p>
    </esql:no-results>
  </esql:execute-query>
</esql:connection>]]>
</source>

    <s3 title="Updates">
     <p>In JDBC, updates, inserts, and deletes are "update queries". For those,
      no results are available but an update count is returned, indicating,
      how many rows were affected.</p>

     <p>Code or content that depends on this has to be placed inside the
      <code>esql:update-results</code> tag. It is used whenever at least one
      row was affected. The update count can be accessed through the
      <code>esql:get-update-count</code> tag.
     </p>

     <p>If no rows where affected, the <code>esql:no-results</code> block is
      used.</p>
    </s3>


   <source><![CDATA[
<esql:connection>
  <esql:pool>connectionName</esql:pool>
  <esql:execute-query>
    <esql:query>update table set price=price*1.17</esql:query>
    <esql:error-results>An error occurred</esql:error-results>
    <esql:update-results>
       <esql:get-update-count/> prices adjusted.
    </esql:update-results>
    <esql:no-results>
       <p>Sorry, no prices adjusted!</p>
    </esql:no-results>
  </esql:execute-query>
</esql:connection>]]>
</source>

   </s2>

   <s2 title="Groups">
    <p>For more complex lists, often nested queries are needed. Esql allows
     arbitrary nesting of queries. However, you can do table joins and then
     insert a header whenever a "watched" column value changes using the
     <code>&lt;esql:group/&gt;</code> and <code>&lt;esql:member/&gt;</code>
     tags.  It follows the nesting ideology of <code>&lt;xsp:logic&gt; ...
      &lt;xsp:content&gt;&lt;/&gt;&lt;/&gt;</code>You can nest
     <code>&lt;esql:group&gt;</code> and <code>&lt;esql:member&gt;</code>
     indefinately. <code>group-on</code> can be an attribute of
     <code>group</code> or a text node. The value of the text node has
     precedence over the attribute. The value can be the column name or the
     column number. 
     </p>

    <source><![CDATA[
<esql:execute-query>
  <esql:query>
    select committeeName, title, firstName, middleName, lastName, suffix, status 
    from committeeMember left join directoryInformation using(userid)
         left join committee on committee.id=committeeMember.committeeid 
    order by committeeName asc
  </esql:query>
  <esql:results>
    <esql:row-results>
      <esql:group group-on="committeeName">
        <h2><esql:get-string column="committeeName"/></h2>
        <ul>
          <esql:member>
            <li>
              <esql:get-string column="title"/>
              <esql:get-string column="firstName"/>
              <esql:get-string column="middleName"/>
              <esql:get-string column="lastName"/>
              <esql:get-string column="suffix"/>
            </li>
          </esql:member>
        </ul>
      </esql:group>
    </esql:row-results>
  </esql:results>
</esql:execute-query>]]>
    </source>

    <p>One important limitation of the grouping feature is, that <em>no access
      to a column may appear after closing a group.</em> The value will belong
     to the following row or cause an error if no next row exists. If this is
     needed, consider swapping columns using XSLT or embedded JAVA. Hence the
     following example is illegal:</p>
   </s2>

    <source><![CDATA[
<esql:execute-query>
  <esql:query>
    select committeeName, committeeTitle, title, firstName, middleName, 
           lastName, suffix, status 
    from committeeMember left join directoryInformation using(userid)
         left join committee on committee.id=committeeMember.committeeid 
    order by committeeName asc
  </esql:query>
  <esql:results>
    <esql:row-results>
      <esql:group group-on="committeeName">
        <h2><esql:get-string column="committeeName"/></h2>
        <ul>
          <esql:member>
            <li>
              <esql:get-string column="title"/>
              <esql:get-string column="firstName"/>
              <esql:get-string column="middleName"/>
              <esql:get-string column="lastName"/>
              <esql:get-string column="suffix"/>
            </li>
          </esql:member>
        </ul>
      </esql:group>
      <esql:get-string column="committeeTitle"/><!-- illegal !! -->
    </esql:row-results>
  </esql:results>
</esql:execute-query>]]>
    </source>


   <s2 title="Stored Procedure Support">
    <p>In order to use stored procedures replace
     <code>&lt;esql:query/&gt;</code> with <code>&lt;esql:call/&gt;</code>, use
     either DBMS specific syntax or JDBC escape syntax <code>{? =
      foo(?)}</code>. If your jdbc driver requires to use the
     <code>executeQuery()</code> method instead of the <code>execute()</code>
     method (like e.g. INFORMIX does), set <code>needs-query="true"</code>
     attribute.</p>

    <p>If a result set is returned through the (only) return parameter of a
     stored procedure, e.g. <code>resultset-from-object="1"</code> as attribute
     to <code>&lt;esql:call/&gt;</code>to automatically use this result set.
     For a more general alternative see further below.</p>

    <p>Parameters for a stored procedure call may be of
	 <code>direction="in|out|inout"</code> with the usual JDBC meaning. In
	 addition a <code>type</code> needs to be supplied for "out" and "inout"
	 parameters. This would be the same "XXX" as used in a <code>get-XXX</code>
	 JDBC-method call. Alternatively, you can use a fully qualified field name,
	 e.g. "java.sql.Types.CHAR"</p> 

    <p><code>&lt;esql:call-results/&gt;</code> (child of
     <code>&lt;esql:execute-query/&gt;</code>) may contain code that will
     always be executed whether the query returned a result or not. For example
     most stored procedures will not return a result set but several out
     parameters.</p>

    <p>All <code>&lt;esql:get-xxx/&gt;</code> tags accept a new attribute
     <code>from-call="yes"</code> to indicate that the value is retrieved from
     the CallableStatement rather than the current ResultSet. Obviously, this
     only works after a call to a stored procedure.</p>

    <p>Retrieve a ResultSet from any column and use it like the result of a
     nested query with the <code>esql:use-results</code> tag. It behaves
     exactly like nesting queries. Thus the <code>ancestor</code> attribute can
     be used to access e.g. the original query.</p>


    <p>Example:</p>
    <source><![CDATA[
<esql:call>{? = foo(<esql:parameter direction="in"
  type="Int"><xsp:expr>1</xsp:expr></esql:parameter>)}
</esql:call>
<esql:call-results>
  <esql:use-results>
    <esql:result><xsp:expr>(ResultSet)<esql:get-object column="1" from-call="true"/></xsp:expr></esql:result>
    <esql:results>
      <esql:row-results>
        <esql:get-string column="1"/>
      </esql:row-results>
    </esql:results>
  </esql:use-results>
</esql:call-results>
]]></source>

    <p>Example:</p>
    <source><![CDATA[
<esql:query>select name, list_of_aliases from table</esql:query>
<esql:results>
  <esql:row-results>
    <p>
      <esql:get-string column="name"/>: 
      <esql:use-results>
        <esql:result><xsp:expr><esql:get-array column="list_of_aliases"/>.getResultSet()</xsp:expr></esql:result>
        <esql:results>
          <esql:row-results>
            <esql:get-string column="1"/>
          </esql:row-results>
        </esql:results>
      </esql:use-results>
    </p>
  </esql:row-results>
</esql:results>
]]></source>

   </s2>

   <s2 title="Multiple Results">
    <p>If multiple results are returned from a stored procedure or a query, the
     <code>esql:results</code> block is reused. However, it is supported to
     have different blocks for each result. Since a result can either be a
     ResultSet or an UpdateCount, both are counted independently. The nth
     ResultSet will be handled by the nth <code>esql:results</code> block, or -
     if there are fewer blocks - the last one.</p>

    <p>The same holds true for <code>esql:update-results</code> and
     <code>esql:no-results</code> blocks as well.</p>

	<note>Support for multiple results is not widely available with DBMSs.
	 Therefore support is disabled by default. Use the
	 <code>&lt;esql:allow-multiple-results&gt;yes&lt;/esql:allow-multiple-results&gt;</code> 
	 parameter to the &lt;esql:connection/&gt;.</note>


    <p>Example: Suppose stored procedure <code>bar</code> returns an update
     count, another update count, a result set, an update count, and a
     last result set.</p>

    <source><![CDATA[
<esql:call>{? = bar(<esql:parameter direction="in"
type="Int"><xsp:expr>1</xsp:expr></esql:parameter>)}
</esql:call>
<esql:results>
  <!-- this is used for the first result set -->
</esql:results>
<esql:results>
  <!-- this is used for the second and 
       all following result sets -->
</esql:results>
<esql:update-results>
  <!-- this is used for the first update count -->
</esql:update-results>
<esql:no-results>
  <!-- this is used for the first update count -->
</esql:no-results>
<esql:update-results>
  <!-- this is used for the second and 
       all following update counts -->
</esql:update-results>
<esql:no-results>
  <!-- this is used for the second and 
       all following update counts -->
</esql:no-results>
]]></source>

   </s2>

   <p>The ultimate reference, is of course the source code, which is an XSLT
    logicsheet contained in the file
    <code>src/org/apache/cocoon/components/language/markup/xsp/java/esql.xsl</code></p>

   <p>Of course, we would be very grateful for any improvements on this
    documentation or further examples - please send them to <link
     href="mailto:users@cocoon.apache.org">users.at.cocoon.apache.org</link>!</p>
   
  </s1>


  <s1 title="Template Descriptions">
   <table>
    <tr>
     <th>Tag</th>
     <th>Description</th>
    </tr>
          <tr><td>esql:row-results//esql:get-columns</td>
          <td>results in a set of elements whose names are the names of the columns. the elements each have one text child, whose value is the value of the column interpreted as a string. No special formatting is allowed here. If you want to mess around with the names of the elements or the value of the text field, use the type-specific get methods and write out the result fragment yourself. For Cocoon 2 only, this outputs structured types as well. Here sql-list or sql-set contains several sql-list-item or sql-set-item element that again contain the actual data.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-string</td>
          <td>returns the value of the given column as a string</td>
          </tr>
          <tr><td>esql:row-results//esql:get-date</td>
          <td>returns the value of the given column as a date. if a format attribute exists, its value is taken to be a date format string as defined in java.text.SimpleDateFormat, and the result is formatted accordingly.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-time</td>
          <td>returns the value of the given column as a time. if a format attribute exists, its value is taken to be a date format string as defined in java.text.SimpleDateFormat, and the result is formatted accordingly.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-timestamp</td>
          <td>returns the value of the given column as a timestamp. if a format attribute exists, its value is taken to be a date format string as defined in java.text.SimpleDateFormat, and the result is formatted accordingly.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-boolean</td>
          <td>returns the value of the given column as true or false</td>
          </tr>
          <tr><td>esql:row-results//esql:get-double</td>
          <td>returns the value of the given column as a double. if a format attribute exists, its value is taken to be a decimal format string as defined in java.text.DecimalFormat, and the result is formatted accordingly.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-float</td>
          <td>returns the value of the given column as a float. if a format attribute exists, its value is taken to be a decimal format string as defined in java.text.DecimalFormat, and the result is formatted accordingly.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-int</td>
          <td>returns the value of the given column as an integer</td>
          </tr>
          <tr><td>esql:row-results//esql:get-long</td>
          <td>returns the value of the given column as a long</td>
          </tr>
          <tr><td>esql:row-results//esql:get-short</td>
          <td>returns the value of the given column as a short</td>
          </tr>
          <tr><td>esql:row-results//esql:get-ascii</td>
          <td>returns the value of the given column as a clob</td>
          </tr>
          <tr><td>esql:row-results//esql:get-object</td>
          <td>returns the value of the given column as an object</td>
          </tr>
          <tr><td>esql:row-results//esql:get-array</td>
          <td>returns the value of the given column as an java.sql.Array. This is frequently used for collection 
          datatypes like lists, sets, bags etc.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-struct</td>
          <td>returns the value of the given column as a java.sql.Struct. This is frequently used for row types.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-xml</td>
          <td>returns the value of the given column interpreted as an xml fragment.
 The fragment is parsed by the default xsp parser and the document element is returned.
 If a root attribute exists, its value is taken to be the name of an element to wrap around the contents of
 the fragment before parsing.</td>
 </tr>
          <tr><td>esql:results//esql:get-column-count</td>
          <td>returns the number of columns in the resultset.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-row-position|esql:results//esql:get-row-position</td>
          <td>returns the position of the current row in the result set</td>
          </tr>
          <tr><td>esql:row-results//esql:get-column-name</td>
          <td>returns the name of the given column. the column must be specified by number, not name.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-column-label</td>
          <td>returns the label of the given column. the column must be specified by number, not name.</td>
          </tr>
          <tr><td>esql:row-results//esql:get-column-type-name</td>
          <td>returns the name of the type of the given column. the column must be specified by number, not name.</td>
          </tr>
          <tr><td>esql:row-results//esql:is-null</td>
          <td>allows null-column testing. Evaluates to a Java expression, which is true when the referred column contains a null-value for the current resultset row</td>
          </tr>
          <tr><td>esql:error-results//esql:get-message</td>
          <td>returns the message of the current exception</td>
          </tr>
          <tr><td>esql:error-results//esql:to-string</td>
          <td>returns the current exception as a string</td>
          </tr>
          <tr><td>esql:error-results//esql:get-stacktrace</td>
          <td>returns the stacktrace of the current exception</td>
          </tr>
          <tr><td>esql:results/esql:get-metadata</td>
          <td>returns the metadata associated with the current resultset</td>
          </tr>
          <tr><td>esql:results/esql:get-resultset</td>
          <td>returns the current resultset</td>
          </tr>
      <tr><td>esql:group</td>
      <td>Allows header elements around groups of consecutive records with identical values in column named by @group-on.  Facilitates a single query with joins to be used in lieu of some nested queries.</td>
          </tr>
      <tr><td>esql:member</td>
      <td>Used in conjunction with and nested inside esql:group.  Formatting for individual records goes within esql:member. Header stuff goes in between group and member.</td>
      </tr>
          <tr><td>@*|node()</td>
          <td>used internally to determine which column is the given column. if a column attribute exists and its value is a number, it is taken to be the column's position. if the value is not a number, it is taken to be the column's name. if a column attribute does not exist, an esql:column element is assumed to exist and to render as a string (after all of the xsp instructions have been evaluated), which is taken to be the column's name.</td>
          </tr>
       </table>
      </s1>

</body></document>
