<?xml version='1.0' encoding='ISO-8859-1'?>
<!--
  Copyright 1999-2004 The Apache Software Foundation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.0//EN" "document-v10.dtd">

<document>
	<header>
		<title>Advanced Control Flow</title> 
		<authors>
			<person name="Christopher Oliver" email="coliver@apache.org" />
		</authors>
	</header>
<body>
	<s1 title="JXTemplate Generator">
  <p>
The JXTemplate Generator is a page template processor that allows you to inject data from Java and JavaScript objects passed by a Cocoon Flowscript into a Cocoon pipeline. It provides a set of tags (similar to the <link href="http://java.sun.com/products/jsp/jstl/">JSTL</link> core tags) that allow you to iterate over Java collections (and Java or JavaScript arrays) and to test for the presence of optional or alternate bean properties, as well as embedded expressions to specify conditions and to access the properties of objects. The <em>JX</em>Template Generator gets its name from the embedded expression languages it supports, namely <link href="http://jakarta.apache.org/commons/jxpath">Apache <em>JX</em>Path</link> and <link href="http://jakarta.apache.org/commons/jexl">Apache <em>J</em>e<em>X</em>l</link>. 
  </p>
<p>To use the JXTemplate Generator, add a generator entry to your <link href="../concepts/sitemap.html">sitemap</link> with the <code>src</code> attribute set to <code>org.apache.cocoon.generation.JXTemplateGenerator</code>, for example like this:</p>
<source>
&lt;map:generators&gt;
  &lt;map:generator label="content,data" 
      logger="sitemap.generator.jx" name="jx" 
         src="org.apache.cocoon.generation.JXTemplateGenerator"/&gt;
&lt;/map:generators&gt;
</source>
  <p/>
         </s1>
         <s1 title="Expression Languages">
  <p>
The JXTemplate Generator supports two embedded expression languages: <link href="http://jakarta.apache.org/commons/jexl">Jexl</link> and <link href="http://jakarta.apache.org/commons/jxpath">JXPath</link>. Apache <link href="http://jakarta.apache.org/commons/jexl">Jexl</link> provides an extended version of the expression language of the <link href="http://java.sun.com/webservices/docs/1.0/tutorial/doc/JSTL.html">JSTL</link>. Apache <link href="http://jakarta.apache.org/commons/jxpath">JXPath</link> provides an interpreter of the <link href="http://www.w3.org/TR/xpath">XPath</link> expression language that can apply XPath expressions to graphs of Java objects of all kinds: JavaBeans, Maps, Servlet contexts, DOM etc, including mixtures thereof.
 </p>
  <p>
 Having an embedded expression language allows a page author to access an object using a simple syntax such as
 </p>
<source>
&lt;site signOn="${accountForm.signOn}"&gt;
 </source>
<p>Embedded Jexl expressions are contained in <code>${}</code>.</p>
<p>Embedded JXPath expressions are contained in <code>#{}</code>.</p>
<p>The referenced objects may be Java Beans, DOM, or JavaScript objects 
from a Flowscript. In addition, a special <code>cocoon</code> object providing access to the Cocoon <link href="api.html#FOM">FOM</link> is available as
both a JXPath and Jexl variable in a template. 
</p>
<p>The <code>cocoon</code> object contains the following properties:</p>

<dl>
<dt><link href="api.html#request">request</link></dt>
<dd><br/>The current Cocoon request<br/></dd>
 
<dt><br/><link href="api.html#session">session</link></dt>
<dd><br/>The user session associated with the current request<br/></dd>
 
<dt><br/><link href="api.html#context">context</link></dt>
<dd><br/>The Cocoon context associated with the current request<br/></dd>
 
<dt><br/><code>parameters</code></dt>
<dd><br/>A map containing the parameters passed to the generator in the pipeline<br/></dd>
<dt><br/><link href="api.html#WebContinuation">continuation</link></dt>
<dd><br/>The current Web Continuation from your Flowscript<br/></dd>
</dl>
<p>
Jexl Example:</p>
<source>
The content type of the current request is ${cocoon.request.contentType}
</source>
<p>
JXPath Example:</p>
<source>
The content type of the current request is #{$cocoon/request/contentType}
</source>
<p> 
You would typically access the <code>id</code> of the Web Continuation:</p>
<source>
&lt;form action="${cocoon.continuation.id}"&gt;
</source>
<p>You can also reach previous continuations via its <code>parent</code> property:</p>
<source>
&lt;form action="${cocoon.continuation.parent.id}" >
</source>
<p>or using an XPath expression:</p>
<source>
&lt;form action="#{$cocoon/continuation/parent/id}" >
</source>

<p>Deprecated Variables:</p>
<p>The following variables are deprecated but still supported:</p>

<dl>
<dt><link href="../../../apidocs/org/apache/cocoon/environment/Request.html">org.apache.cocoon.environment.Request</link> <code>request</code></dt>
<dd><br/>The current Cocoon request (deprecated: use <code>cocoon.request</code> instead)<br/></dd>

<dt><link href="../../../apidocs/org/apache/cocoon/environment/Session.html">org.apache.cocoon.environment.Session</link> <code>session</code></dt>
<dd><br/>The current user session (deprecated: use <code>cocoon.session</code> instead)<br/></dd>
 
<dt><link href="../../../apidocs/org/apache/cocoon/environment/Context.html">org.apache.cocoon.environment.Context</link> <code>context</code></dt>
<dd><br/>The current context (deprecated: use <code>cocoon.context</code> instead)<br/></dd>

<dt><link href="../../../apidocs/org/apache/cocoon/components/flow/WebContinuation.html">org.apache.cocoon.components.flow.WebContinuation</link> <code>continuation</code></dt>
<dd><br/>The current Web Continuation (deprecated: use <code>cocoon.continuation</code> instead)<br/></dd>
</dl>
</s1>

<s1 title ="Parameters">
<s2 title="lenient-xpath">
<p>
By default XPath evaluation throws an exception if the supplied XPath does not map to an existing property. This constraint can be relaxed by setting the parameter <code>lenient-xpath</code> to <code>true</code>. In the lenient mode evaluation simply returns null if the path maps to nothing.
</p>
<p>
Example:
</p>
<source>
<![CDATA[
    <map:match pattern="*.jx">
      <map:generate type="jx" src="documents/{1}.jx">
           <map:parameter name="lenient-xpath" value="true"/>
      </map:generate>
      <map:serialize type="xhtml"/>
    </map:match>
]]>
</source>
</s2>
</s1>
<s1 title ="Tags">
<p>The JXTemplate Generator tags are defined in the namespace</p>
<source>
http://apache.org/cocoon/templates/jx/1.0
</source>
<s2 title ="template">
<p>The <code>template</code> tag defines a new template:</p><source>
&lt;jx:template xmlns:jx="http://apache.org/cocoon/templates/jx/1.0"&gt;
   body
&lt;/jx:template&gt;
</source>
</s2>
<s2 title ="import"/>
<p>The <code>import</code> tag allows you to include another template within the current template. The content of the imported template is compiled and will be executed in place of the <code>import</code> tag:</p><source>
&lt;jx:import uri="URI" [context="Expression"]/&gt;
</source><p>The Cocoon source resolver is used to resolve <code>uri</code>. If <code>context</code> is present, then its value is used as the context for evaluating the imported template, otherwise the current context is used.</p>
<s2 title ="set">
<p>The <code>set</code> tag creates a local alias of an object. The <code>var</code> attribute specifies the name of a variable to assign the object to. The <code>value</code> attribute specifies the object (defaults to <code>body</code> if not present):</p><source>
&lt;jx:set var="Name" [value="Value"]&gt;
   [body]
&lt;/jx:set&gt;
</source><p>If used within a <code>macro</code> definition (see below) variables created by <code>set</code> are only visible within the body of the <code>macro</code>.</p>
<p>Jexl Example:</p>
<source>
&lt;jx:set var="greeting" value="Hello ${user}"/&gt;
The value of greeting is ${greeting}
</source>
<p>JXPath Example:</p>
<source>
&lt;jx:set var="greeting" value="Hello #{user}"/&gt;
The value of greeting is #{$greeting}
</source>
 <p/>
</s2>
<s2 title ="if">
<p>The <code>if</code> tag allows the conditional execution of its body 
according to value of its <code>test</code> attribute:</p>
<source>
&lt;jx:if test="Expression"&gt;
  body
&lt;/jx:if&gt;
</source>
<p>Jexl Example:</p>
<source>
&lt;jx:if test="${cart.numberOfItems == 0}"&gt;
  Your cart is empty
&lt;/jx:if&gt;
</source>
<p/>
<p>JXPath Example:</p>
<source>
&lt;jx:if test="#{cart/numberOfItems = 0}"&gt;
  Your cart is empty
&lt;/jx:if&gt;
</source>
 <p/>
</s2>
<s2 title ="choose">
<p>The <code>choose</code> tag performs conditional block execution by its 
embedded <code>when</code> sub tags. It renders the body of the first 
<code>when</code> tag whose <code>test</code> condition evaluates to true. 
If none of the <code>test</code> conditions of its nested <code>when</code> tags
evaluate to <code>true</code>, then the body of its <code>otherwise</code> 
tag is evaluated, if present:</p>
<source>
&lt;jx:choose&gt;
  &lt;jx:when test="Expression"&gt;
    body
  &lt;/jx:when&gt;+
  &lt;jx:otherwise&gt;
    body
  &lt;/jx:otherwise&gt;?
&lt;/jx:choose&gt;
</source>
<p>Jexl Example:</p>
<source>
&lt;jx:choose&gt;
  &lt;jx:when test="${!user.loggedIn}"&gt;
    &lt;jx:set var="label" value="Log in"&gt;
  &lt;/jx:when&gt;
  &lt;jx:otherwise&gt;
    &lt;jx:set var="label" value="Log out"&gt;
  &lt;/jx:otherwise&gt;
&lt;/jx:choose&gt;
</source>
 <p/>
<p>JXPath Example:</p>
<source>
&lt;jx:choose&gt;
  &lt;jx:when test="#{not(user/loggedIn)}"&gt;
    &lt;jx:set var="label" value="Log in"&gt;
  &lt;/jx:when&gt;
  &lt;jx:otherwise&gt;
    &lt;jx:set var="label" value="Log out"&gt;
  &lt;/jx:otherwise&gt;
&lt;/jx:choose&gt;
</source>
 <p/>
</s2>
<s2 title="out">
<p>The <code>out</code> tag evaluates an expression and outputs 
the result of the evaluation:</p>
<source>
&lt;jx:out value="Expression"/&gt;
</source>
<p>Jexl Example:</p>
<source>
&lt;jx:out value="${cart.numberOfItems}"&gt;
</source>
<p>JXPath Example:</p>
<source>
&lt;jx:out value="#{cart/numberOfItems}"&gt;
</source>
 <p/>
</s2>
<s2 title="forEach">
<p>The <code>forEach</code> tag allows you to iterate over a collection 
of objects:</p>
<source>
&lt;jx:forEach [var="Name"] [varStatus="Name"] [items="Expression"] 
               [begin="NumExpr"] [end="NumExpr"] [step="NumExpr"]&gt;
  body
&lt;/jx:forEach&gt;
</source>
<p>The <code>items</code> attribute specifies the list of items to iterate over. The <code>var</code> attribute specifies the name of a variable to hold the current item. The <code>begin</code> attribute specifies the element to start with 
(<code>0</code> = first item, <code>1</code> = second item, ...). 
If unspecified it defaults to <code>0</code>. The <code>end</code> 
attribute specifies the item to end with (<code>0</code> = first item, 
<code>1</code> = second item, ...). If unspecified it defaults to the last item in the list. Every <code>step</code> items are
processed (defaults to <code>1</code> if <code>step</code> is absent). Either <code>items</code> or both <code>begin</code> and <code>end</code> must be present.</p>

<p>An alternate form of <code>forEach</code> is supported for convenience when using XPath (since you can specify the selection criteria for the collection using XPath itself):</p>
<source>
&lt;jx:forEach select="XPathExpression"&gt;
  body
&lt;/jx:forEach&gt;
</source>
<p>When using XPath expressions within <code>forEach</code> the current element is the context node and can be referenced with: 
<code>#{.}</code></p>
<p>Jexl Example:</p>
<source>
&lt;jx:forEach var="item" items="${cart.cartItems}" 
               begin="${start}" end="${count-start}" step="1"&gt;
   &lt;td&gt;${item.productId}&lt;/td&gt;
&lt;/jx:forEach&gt;
</source>
 <p/>
<p>JXPath Example:</p>
<source>
&lt;jx:forEach select="#{cart/cartItems[position() &amp;lt;= $count]}}&gt;
   &lt;td&gt;#{./productId}&lt;/td&gt;
&lt;/jx:forEach&gt;
</source>
 <p>
If the <code>varStatus</code> attribute is present a variable will be created to hold information about the current loop status. The variable named by the <code>varStatus</code> attribute will hold a reference to an object with the following properties:</p>
    <table>
     <tr>
       <td>
       Property:
       </td>
       <td>
       Description:
       </td>
     </tr>
     <tr>
       <td>
       current
       </td>
       <td>
       The item from the collection for the current round of iteration
       </td>
     </tr>
     <tr>
       <td>
       index
       </td>
       <td>
       The zero-based index for the current round of iteration
       </td>
     </tr>
     <tr>
       <td>
       count
       </td>
       <td>
       The one-based count for the current round of iteration
       </td>
     </tr>
     <tr>
       <td>
       first
       </td>
       <td>
       True if this is the first round of iteration
       </td>
     </tr>
     <tr>
       <td>
       last
       </td>
       <td>
       True if this is the last round of iteration
       </td>
     </tr>
     <tr>
       <td>
       begin
       </td>
       <td>
       The value of the <code>begin</code> attribute
       </td>
     </tr>
     <tr>
       <td>
       end
       </td>
       <td>
       The value of the <code>end</code> attribute
       </td>
     </tr>
     <tr>
       <td>
       step
       </td>
       <td>
       The value of the <code>step</code> attribute
       </td>
     </tr>
    </table>
<p>Jexl Example:</p>
<source>
&lt;jx:forEach items="${items}" varStatus="status"&gt;
    index=${status.index},
    count=${status.count},
    current=${status.current},
    first=${status.first},
    last=${status.last},
    begin=${status.begin},
    end=${status.end}
&lt;/jx:forEach&gt;
</source>
 <p/>
<p>JXPath Example:</p>
<source>
&lt;jx:forEach select="#{items}" varStatus="status"&gt;
    index=#{$status/index},
    count=#{$status/count},
    current=#{$status/current},
    first=#{$status/first},
    last=#{$status/last},
    begin=#{$status/begin},
    end=#{$status/end}
&lt;/jx:forEach&gt;
</source>
</s2>
<s2 title="formatNumber">
<p>
The <code>formatNumber</code> tag is used to display numeric data, including currencies and percentages, in a locale-specific manner. It determines from the locale, for example, whether to use a period or a comma for delimiting the integer and decimal portions of a number. Here is its syntax: 
</p>
<source>
&lt;jx:formatNumber value="Expression"
    [type="Type"] [pattern="Expression"]
    [currencyCode="Expression"] [currencySymbol="Expression"]
    [maxIntegerDigits="Expression"] [minIntegerDigits="Expression"]
    [maxFractionDigits="Expression"] [minFractionDigits="Expression"]
    [groupingUsed="Expression"]
    [var="Name"] [locale="Expression"]&gt;
</source>
<p>
Only the <code>value</code> attribute is required. It is used to specify the numeric value that is to be formatted.
</p>
<p>
The value of the <code>type</code> attribute should be either "number", "currency", or "percent", and indicates what type of numeric value is being formatted. The default value for this attribute is "number". The <code>pattern</code> attribute takes precedence over the <code>type</code> attribute and allows more precise formatting of numeric values following the pattern conventions of the <code>java.text.DecimalFormat</code> class. 
</p>
<p>
When the <code>type</code> attribute has a value of "currency", the <code>currencyCode</code> attribute can be used to explicitly specify the currency for the numerical value being displayed. As with language and country codes, currency codes are governed by an ISO standard. This code is used to determine the currency symbol to display as part of the formatted value. 
</p>
<p>
Alternatively, you can use the <code>currencySymbol</code> attribute to explicitly specify the currency symbol. Note that as of JDK 1.4 and the associated introduction of the <code>java.util.Currency</code> class, the <code>currencyCode</code> attribute of <code>formatNumber</code> takes precedence over the <code>currencySymbol</code> attribute. For earlier versions of the JDK, however, the <code>currencySymbol</code> attribute takes precedence. 
</p>
<p>
The <code>maxIntegerDigits</code>, <code>minIntegerDigits</code>, <code>maxFractionDigits</code>, and <code>minFractionDigits</code> attributes are used to control the number of significant digits displayed before and after the decimal point. These attributes require integer values. 
</p>
<p>
The <code>groupingUsed</code> attribute takes a <code>Boolean</code> value and controls whether digits before the decimal point are grouped. For example, in English-language locales, large numbers have their digits grouped by threes, with each set of three delimited by a comma. Other locales delimit such groupings with a period or a space. The default value for this attribute is <code>true</code>. 
</p>

</s2>
<s2 title="formatDate">
<p>The <code>formatDate</code> tag provides facilities to format Date values:</p> 
<source>
&lt;jx:formatDate value="Expression" [dateStyle="Style"] 
  [timeStyle="Style"] [pattern="Expression"] [type="Type"] [var="Name"] 
  [locale="Expression"]&gt;
</source>
<p>
Only the value attribute is required. Its value should be an instance of the <code>java.util.Date</code> class, specifying the date and/or time data to be formatted and displayed.</p>

<p>The optional <code>timeZone</code> attribute indicates the time zone in which the date and/or time are to be displayed. If not present, then the JVM's default time zone is used (that is, the time zone setting specified for the local operating system). </p>
<p>
The <code>type</code> attribute indicates which fields of the specified <code>Date</code> instance are to be displayed, and should be either "time", "date", or "both". The default value for this attribute is "date", so if no <code>type</code> attribute is present, the <code>formatDate</code> tag -- true to its name -- will only display the date information associated with the <code>Date</code> instance, specified using the tag's value attribute. 
</p>
<p>
The <code>dateStyle</code> and <code>timeStyle</code> attributes indicate how the date and time information should be formatted, respectively. Valid styles are "default", "short", "medium", "long", and "full". The default value is, naturally, "default", indicating that a locale-specific style should be used. The semantics for the other four style values are as defined by the java.text.DateFormat class. 
</p>
<p>
Rather than relying on the built-in styles, you can use the pattern attribute to specify a custom style. When present, the value of the pattern attribute should be a pattern string following the conventions of the java.text.SimpleDateFormat class. These patterns are based on replacing designated characters within the pattern with corresponding date and time fields. For example, the pattern MM/dd/yyyy indicates that two-digit month and date values and a four-digit year value should be displayed, separated by forward slashes. 
</p>
<p>
If the <code>var</code> attribute is specified, then a String value containing the formatted date is assigned to the named variable. Otherwise, the <code>formatDate</code> tag will write out the formatting results.
</p>
</s2>
<s2 title="macro"> 
<p>The <code>macro</code> tag allows you define a new custom tag.</p><source>
&lt;jx:macro name="Name" [targetNamespace="Namespace"]&gt;
  &lt;jx:parameter name="Name" [optional="Boolean"] [default="Value"]/&gt;*
  body
&lt;/jx:macro&gt;
</source>
 <p> For example:</p><source>
&lt;jx:macro name="d"&gt;
  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/jx:macro&gt;
</source>
<p>The tag being defined in this example is <code>&lt;d&gt;</code> and it 
can be used like any other tag:</p><source>
&lt;d/&gt;
</source>
<p>However, when this tag is used it will be replaced with a row containing a single empty data cell.</p>
<p> When such a tag is used, the attributes and content of the tag become available as variables in the body of the <code>macro</code>'s definition, for example:</p><source>
&lt;jx:macro name="tablerows"&gt;
  &lt;jx:parameter name="list"/&gt;
  &lt;jx:parameter name="color"/&gt;
  &lt;jx:forEach var="item" items="${list}"&gt;
    &lt;tr&gt;&lt;td bgcolor="${color}"&gt;${item}&lt;/td&gt;&lt;/tr&gt;
  &lt;/jx:forEach&gt;
&lt;/jx:macro&gt;
</source>
<p>The <code>parameter</code> tags in the macro definition define formal parameters, which are replaced with the actual attribute values of the tag when it is used.</p><p>Assuming you had this code in your flowscript:</p>
   <source>var greatlakes = ["Superior", "Michigan", "Huron", "Erie", "Ontario"];
   sendPage(uri, {greatlakes: greatlakes});</source>
<p>and a template like this:</p><source>
&lt;table&gt;
   &lt;tablerows list="${greatlakes}" color="blue"/&gt;
&lt;/table&gt;
</source>
<p>When the <code>tablerows</code> tag is used in this situation the following output would be generated:
</p>
 <source>
&lt;table&gt;
  &lt;tr&gt;&lt;td bgcolor="blue"&gt;Superior&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td bgcolor="blue"&gt;Michigan&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td bgcolor="blue"&gt;Huron&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td bgcolor="blue"&gt;Erie&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td bgcolor="blue"&gt;Ontario&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</source>
</s2>
<s2 title="evalBody"> 
<p>Within the body of a macro the <code>evalBody</code> tag treats the content of the macro tag invocation as a <em>JX</em>Template and executes it. For example, the below macro uses this facility to implement the <link href="http://java.sun.com/products/jsp/jstl/">JSTL</link> <code>forTokens</code> tag:
</p>
<source>
<![CDATA[
<jx:macro name="forTokens">
  <jx:parameter name="var"/>
  <jx:parameter name="items"/>
  <jx:parameter name="delims"/>
  <jx:forEach var="${var}" 
         items="${java.util.StringTokenizer(items, delims)}">
    <jx:evalBody/>
  </jx:forEach>
</jx:macro>
]]> </source>
<p>
The tag produced by this macro can be used like this:
</p>
<source>
<![CDATA[
<forTokens var="letter" items="a,b,c,d,e,f,g" delims=",">
  letter = ${letter} <br/>
</forTokens>
]]> </source>
<p>
which would create the following output:
</p>
<source>
<![CDATA[
  letter = a  <br/>  
  letter = b  <br/>  
  letter = c  <br/>  
  letter = d  <br/>  
  letter = e  <br/>  
  letter = f  <br/>  
  letter = g  <br/>  
]]> </source>
</s2>
<s2 title="eval"> 
<p>
The <code>eval</code> tag permits dynamic evaluation of custom tags. 
</p>
<source>
&lt;jx:eval select="Expression"/&gt;
</source>
<p>
Within the body of a macro, information about the current invocation is available via a special variable <code>macro</code>. This variable contains the following properties:
</p>
    <table>
     <tr>
       <td>
       Property:
       </td>
       <td>
       Description:
       </td>
     </tr>
     <tr>
       <td>
       arguments
       </td>
       <td>
       A map containing the all of the attributes from the tag invocation
       </td>
     </tr>
     <tr>
       <td>
       body
       </td>
       <td>
       A reference to the content of the tag invocation
       </td>
     </tr>
   </table>
<p>
You can store the value of <code>body</code> in another variable and invoke it later using <code>jx:eval</code>. The <code>select</code> attribute of <code>jx:eval</code> specifies an expression that must evaluate to a macro invocation. For example:
</p>
<source>
<![CDATA[

<jx:set var="tags" value="${java.util.HashMap()}"/>

<jx:macro name="dynamic-tag">
  <jx:parameter name="id"/>
  <jx:set var="ignored" value="${tags.put(id, macro.body)}"/>
</jx:macro>

<dynamic-tag id="example">
  <em>This tag was invoked dynamically</em>
</dynamic-tag>

<p>I'm about to invoke a dynamic tag:</p>
<jx:eval select="${tags.example}"/> 

]]> 

</source>
<p>
The above template produces the following output:
</p>
<source>
<![CDATA[
<p>I'm about to invoke a dynamic tag:</p>

  
<em>This tag was invoked dynamically</em>
]]> 
</source>
</s2>
</s1>
</body>
</document>
