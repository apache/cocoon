<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE page SYSTEM "./dtd/page.dtd">

<page title="User Guide">
 <authors>
  <author name="Stefano Mazzocchi" email="stefano@apache.org"/>
 </authors>

<section title="Introduction">
  <p>This document assumes the knowledge of the W3C recommendation
  or working drafts used in Cocoon (mainly <link href="http://www.w3.org/TR/REC-xml">XML</link>,
  <link href="http://www.w3.org/TR/WD-xsl">XSL</link> in both its <link href="http://www.w3.org/TR/WD-xslt">transformation</link>
  and <link href="http://www.w3.org/TR/WD-xsl">formatting</link> capabilities). This
  document is not intended to be an XML or XSL tutorial but just shows how these
  technologies may be used inside the Cocoon framework to create web content.</p>
</section>

<section title="General overview">
  <p>Cocoon is a publishing system that allows you to separate web development in three different
  layers: content, style and logic.</p>
  
  <p>Cocoon does not aim to simplify the creation of web content: in fact, it is harder to
  create XML/XSL content than it is to use HTML from the beginning. So, if you
  are happy with the web technology you are using today, don't waste your time
  and stick with what you already have. Otherwise, if your troubles are site
  management, if your graphic people is always in the way, if you HTML authors
  always mess up your page logic, if your managers see no results in hiring new
  people to work on the site, go on and make your life easier.</p>
  
  <p>This comment posted on the Cocoon mail list shows you what we mean:</p>
  
<source>
I've got a site up and running that uses Cocoon. It rocks, the management 
loves me (they now treat me like I walk on water), and a couple of summer 
interns that I had helping me on the project are suddenly getting massively 
head-hunted by companies like AT&amp;T now that they can put XML and XSL on 
their resumes.  In a word: Cocoon simply rocks!</pre>
</source>
</section>

<section title="Hello World">
  <p>Every good user guide starts with an <code>Hello World</code> example and since we hope to
  write good documentation (even if its hard like hell!), we start from there
  too. Here is a well-formed XML file that uses a custom and simple DTD</p>
  
<source><![[CDATA[
<?xml version="1.0"?>
<page>
 <title>Hello World!</title>
 <content>
  <paragraph>This is my first Cocoon page!</paragraph>
 </content>
</page>
]]></source>
  
  <p>Even if this page mimics HTML (in a sense, HTML was born as a simple DTD
  for homepages), it is helpful to note that there is no style information
  and all the styling and graphic part is missing. Where do I put the title? How
  do I format the paragraph? How do I separated the content from the other
  elements? All these questions do not have answers because in this context they
  don't need one: this file should be created and maintained by people that
  don't need to be aware of how this content if further processed to become a
  served web document.</p>
  
  <p>On the other hand, we need to indicate how the presentation questions will
  be answered. To do this, we must indicate a <em>stylesheet</em> that is able to
  indicate how to interpret the elements found in this document. Thus, we
  follow a <link href="http://www.w3.org/TR/WD-xml-stylesheet">W3C recommendation</link>
  and add the XML processing instruction to map a stylesheet to a document:</p>
  
  <source><![CDATA[<ml-stylesheet href"hello.xsl" type="text/xsl">]]></source>
  
  <p>Now that our content layer is done, we need to create a stylesheet to
  convert it to a format readable by our web clients. Since most available web
  clients use HTML as their <em>lingua franca</em>, we'll write a stylesheet to
  convert our XML in HTML (More precisely, we convert to XHTML which is the XML
  form of HTML, but we don't need to be that precise at this point).</p>
  
  <p>Every valid stylesheet must start with the root element <em>stylesheet</em>
  and define its own namespace accordingly to the W3C directions. So the
  skeleton of your stylesheet is:</p>
  
<source><![[CDATA[
<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/XSL/Transform/1.0">
</xsl:stylesheet>
]]></source>

  <p>Once the skeleton is done, you must include your <code>template</code> elements,
  which are the basic unit of operation for the XSLT language. Each template is
  matched against the occurrence of some elements in the original document and
  the element is replaced with the children elements, if they belong to other
  namespaces, or, if they belong to the XSLT namespace, they are further
  processed in a recursive way.</p>
  
  <p>Let's make an example: in our <code>HelloWorld.xml</code> document <code>page</code> is the
  root element. This must be transformed in all those tags that identify a good
  HTML page. Your template becomes:</p>
  
<source><![[CDATA[
<xsl:template match="page">
 <html>
  <head>
   <title><xsl:value-of select="title"/></title>
  </head>
  <body bgcolor="#ffffff">
   <xsl:apply-templates/>
  </body>
 </html>
</xsl:template>
]]></source>
             
  <p>were some elements belong to the standard namespace (which we associate to
  HTML) and some others to the <em>xsl:</em> namespace. Here we find two of those
  XSLT elements: <code>value-of</code> and <code>apply-templates</code>. While 
  the first <em>searches</em> the <code>page</code> element direct children for the 
  <code>title</code> element and
  replace itself with the content of the retrieved element, the second indicates
  to the processor that should continue the processing of the other templates
  described in the stylesheets from that point.</p>
  
  <p>Other possible templates are:</p>
  
<source><![[CDATA[
<xsl:template match="title">
 <h1 align="center">
  <xsl:apply-templates/>
 </h1>
</xsl:template>

<xsl:template match="paragraph">
 <p align="center">
  <i><xsl:apply-templates/></i>
 </p>
</xsl:template> 
]]></source> 

  <p>After the XSLT processing, the original document is transformed to</p>

<source><![[CDATA[
<html>
 <head>
  <title>Hello</title>
 </head>
 <body bgcolor="#ffffff">
  <h1 align="center">Hello</h1>
  <p align="center">
   <i>This is my first Cocoon page!</i>
  </p>
 </body>
</html>
]]></source>

</section>

<section title="Browser Dependent Styling">
  <p>When a document is processed by an XSLT processor, its output is exactly the same for every browser that requested
  the page. Sometimes it's very helpful to be able to discriminate the client
  capabilities and transform content layer into different views/formats. This is
  extremely useful when we want to serve content do very different types of
  clients (fat clients like desktop workstations and thin clients like wireless
  PDAs) but we want to use the same informative source and create the smallest
  possible impact on the site management costs.</p>
  
  <p> Cocoon is able to discriminate between browsers, allowing the different stylesheets to
  be applied. This is done by indicating in the stylesheet linking PI the <em>media</em>
  type, for example, continuing with the HelloWorld.xml document, these PIs</p>
  
<source><![[CDATA[
<?xml version="1.0"?>
<?xml-stylesheet href="hello.xsl" type="text/xsl"?>
<?xml-stylesheet href="hello.text.xsl" type="text/xsl" media="lynx"?>

...
]]>
</source>

  <p>would tell Cocoon to apply the <code>hello.text.xsl</code> stylesheet if the Lynx browser
  is requesting the page. This powerful feature allows you to design your content
  independently and to choose its presentation depending on the capabilities of the browser
  agent.</p>

  <p>The media type of each browser is evaluated by Cocoon at request time,
  based on their <code>User-Agent</code> http header information.
  Cocoon is preconfigured to handle these browsers:</p>
  
  <list>
    <item name="explorer">any Microsoft Internet Explorer, searches for <em>MSIE</em> (before
      searching for Mozilla, since they include it too)</item>
    <item name="opera">the Opera browser (before searching for Mozilla, since
      they include it too)</item>
    <item name="lynx">the text-only Lynx browser</item>
    <item name="java">any Java code using standard URL classes</item>
    <item name="wap">the Nokia WAP Toolkit browser</item>
    <item name="netscape">any Netscape Navigator, searches for <em>Mozilla</em></item>
  </list>
  
  <p>but you can add your own by personalizing the <code>cocoon.properties</code> file
  modify the <code>browser</code> properties. For example</p>
  
<source><![[CDATA[
browser.0=explorer=MSIE
browser.1=opera=Opera
browser.2=lynx=Lynx
browser.3=java=Java
browser.4=wap=Wapsody
browser.5=netscape=Mozilla
]]></source>
    
  <p>indicates that Cocoon should look for the token <em>MSIE</em> inside the
  User-Agent HTTP request header first, then <em>Opera</em>
  and so on, until <em>Mozilla</em>. If you want to recognize different generations of the same browser you should
  do find the specific string you should look for and indicate the order of searching since
  more browsers may contain the same string.</p>
</section>

 <section title="Cocoon Internals">
  <p>The Cocoon publishing system has an engine based on the <em>reactor</em> design
  pattern which is described in the picture below:</p>
  
  <image src="images/schema.jpg" title="Cocoon Schema">
  
  <p>Let's describe the components that appear on the schema:</p>
  
  <list>
   <item name="Request">wraps around the client's request and
     contains all the information needed by the processing engine. The request
     must indicate what client generated the request, what URI is being
     requested and what producer should handle the request.</item>
   <item name="Producer"handles the requested URI and produces an
     XML document. Since producers are pluggable, they work like subservlets
     for this framework, allowing users to define and implement their own
     producers. A producer is responsible of creating the XML document which is
     fed into the processing reactor. It's up to the producer implementation to
     define the function that produces the document from the request object.</item>
   <item name="Reactor">is responsible of evaluating what
     processor should work on the document by reacting on XML processing
     instructions. The reactor pattern is different from a processing pipeline
     since it allows the processing path to the dynamically configurable and it
     increases performance since only those required processors are called to
     handle the document. The reactor is also responsible to forward the
     document to the appropriate formatter.</item>
   <item name="Formatter">transforms the memory representation of
     the XML document into a stream that may be interpreted by the requesting
     client. Depending on other processing instructions, the document leaves
     the reactor and gets formatted for its consumer. The output MIME type of
     the generated document depends on the formatter implementation.</item>
   <item name="Response">encapsulates the formatted document along
     with its properties (such as length, MIME type, etc..)</item>
   <item name="Loader">is responsible of loading the formatted
     document when this is executable code. This part is used for compiled
     server pages where the separation of content and logic is merged and
     compiled into a Producer. When the formatter output is executable code, it
     is not sent back to the client directly, but it gets loaded and executed
     as a document producer. This guarantees both performance improvement
     (since the producer are cached) as well as easier producer development,
     following the common compiled server pages model. [this part is not yet
     implemented]</item>
   </list>
  </section>
  
<section title="Cocoon Processing Instructions">
  <p>The Cocoon reactor uses XML processing instructions to forward the document
  to the right processor or formatter. These processing instructions are:</p>
  
<source><![[CDATA[
<?cocoon-process type="xxx"?> for processing

      and

<?cocoon-format type="yyy"?> for formatting
]]></source>

  <p>These PIs are used to indicate the processing and formatting path that the
  document should follow to be served. In the example above, we didn't use them
  and Cocoon wouldn't know (rather than by the presence of the XSL PIs) that the
  document should be processed by the XSLT processor. To do this, the HelloWorld.xml
  document should be modified like this:</p>
  
<source><![[CDATA[
<?xml version="1.0"?>
<?cocoon-process type="xslt"?>
<?xml-stylesheet href="hello.xsl" type="text/xsl"?>
<page>
 <title>Hello World!</title>
 <content>
  <paragraph>This is my first Cocoon page!</paragraph>
 </content>
</page>
]]></source>  
  
  <p>The other processing instruction is used to indicate what formatter should
  be used to transform the document tree into a suitable form for the requesting
  client. For example, in the document below that uses the XSL formatting object
  DTD, the Cocoon PI indicates that this document should be formatted using the
  formatter associated to the <code>text/xslfo</code> document type.</p>

<source><![[CDATA[
<?xml version="1.0"?>
<?cocoon-format type="text/xslfo"?>

<fo:root xmlns:fo="http://www.w3.org/XSL/Format/1.0">
 <fo:layout-master-set>
  <fo:simple-page-master page-master-name="one" margin-left="100pt" margin-right="100pt">
   <fo:region-body margin-top="50pt" margin-bottom="50pt"/>
  </fo:simple-page-master>
 </fo:layout-master-set>
 
 <fo:page-sequence>
  <fo:sequence-specification>
   <fo:sequence-specifier-repeating page-master-first="one" page-master-repeating="one"/>
  </fo:sequence-specification>
  
  <fo:flow font-size="14pt" line-height="14pt">
   <fo:block>Welcome to Cocoon</fo:block>  
  </fo:flow>  
 </fo:page-sequence> 
</fo:root>
]]></source>  
 
  <p>Cocoon comes with a number of processors and formatters which are
  configured as follows</p>
  
  <table>
   <row>
      <element>type</element>
      <element>class</element>
      <element></element>
   </row>
   <row>
      <element rowspan="3">Processors</element>
      <element><em>xslt</em></element>
      <element>org.apache.cocoon.processor.xslt.XSLPProcessor</element>
      <element>The XSLT Processor</element>
    </row>
    <row>
      <element><em>dcp</em></element>
      <element>org.apache.cocoon.processor.dcp.DCPProcessor</element>
      <element>The <link href="dcpprocessor.html">DCP</link> Processor</element>
    </row>
    <row>
      <element><em>sql</em></element>
      <element>org.apache.cocoon.processor.sql.SQLProcessor</element>
      <element>The <link href="sqlprocessor.html">SQL</link> Processor</element>
    </row>
    <row>
      <element rowspan="5">Formatters</element>
      <element><em>text/xml</em></element>
      <element>org.apache.cocoon.formatter.xml.OpenXMLXMLFormatter</element>
      <element>General XML Formatter</element>
    </row>
    <row>
      <element><em>text/html</em></element>
      <element>org.apache.cocoon.formatter.html.OpenXMLHTMLFormatter</element>
      <element>HTML 4.0 Formatter</element>
    </row>
    <row>
      <element><em>text/xhtml</em></element>
      <element>org.apache.cocoon.formatter.xhtml.OpenXMLXHTMLFormatter</element>
      <element>XHTML Formatter</element>
    </row>
    <row>
      <element><em>text/wml</em></element>
      <element>org.apache.cocoon.formatter.wml.OpenXMLWMLFormatter</element>
      <element>WML 1.1 Formatter</element>
    </row>
    <row>
      <element><em>text/xslfo</em></element>
      <element>org.apache.cocoon.formatter.pdf.FOPFormatter</element>
      <element>PDF Formatter</element>
    </row>
   </table>
</section>

<section title="Cocoon Cache System">
  <p>In a complex server environment like Cocoon, performance and
  memory usage are critical issues. Moreover, the processing requirement for
  both XML parsing, XSLT transformations, document processing and formatting are
  too heavy even for the lightest serving environment based on the fastest
  virtual machine. For this reason, a special cache system was designed underneath the Cocoon
  engine and its able to cache both static and dynamically created pages.</p>
  
  <p>Its operation is simple but rather powerful:</p>
  
  <list>
   <item>when the request comes, the cache is searched.
    <list>
     <item>if the request is found;
      <list>
       <item>its <em>changeable</em> points are evaluated</item>
       <item>if all changeable points are unchanged
        <list>
         <item>the page is served directly from the cache</item>
        </list>
       </item>
       <item>if a single point has changed and requires reprocessing
        <list>
         <item>the page is invalidated and continues as if it wasn't found</item>
        </list>
       </item>
      </list>
     </item>
     <item>if the request is not found:
      <list>
       <item>the page is normally processed</item>
       <item>it's sent to the client</item>
       <item>it's stored into the cache</item>
      </list>
     </item>
    </list>
   </item>
  </list>
  
  <p>This special cache system is required since the page is
  processed with the help of many components which, independently, may change
  over time. For example, a stylesheet or a file template may be updated on
  disk. Every processing logic that may change its behavior over time it's
  considered <em>changeable</em> and checked at request time for change.</p>
  
  <p>Each changeable point is queried at request time and it's up
  to the implementation to provide a fast method to check if the stored page is
  still valid. This allows even dynamically generated pages (for example,
  an XML template page created by querying a database) to be cached and,
  assuming that request frequency is higher than the resource changes, it
  greatly reduces the total server load.</p>
  
  <p>Moreover, the cache system is based on a persistent object
  storage system which is able to save stored objects in a persistent state that
  outlives the JVM execution. This is mainly used for pages that are very
  expensive to generate and last very long without changes, such as compiled
  server pages. [this part is not yet implemented]</p>
  
  <p>The store system is responsible of handling the cached pages
  as well as the pre-parsed XML documents. This is mostly used by XSLT
  processors which store their stylesheets in a pre-parsed form to speed up
  execution in those cases where the original file has changed, but the
  stylesheet has not (which is a rather frequent case).</p>
</section>
</page>
