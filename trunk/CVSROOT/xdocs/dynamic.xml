<?xml version="1.0"?>

<!DOCTYPE document SYSTEM "./dtd/document-v10.dtd">

<document>
 <header>
  <title>Dynamic XML in Cocoon</title>
  <authors>
   <person name="Stefano Mazzocchi" email="stefano@apache.org"/>
  </authors>
 </header>
 <body>
 
<s1 title="Introduction">
  <p>Web publishing is very limited without the ability to create
  dynamic content. By dynamic XML we mean the content that is created as a
  function of request parameters or state of the requested resource. For this
  reason, a lot of work and design has been put into Cocoon to allow dynamic XML
  content to be generated.</p>
</s1>

<s1 title="The Servlet/JSP model">
  <p>People are used to writing small Java programs to create their
  dynamic web content. Servlets, and Java in general, are very powerful, easy to
  write and fast to debug, but they impose (like any other pure-logic solution)
  a significant management cost. This is due to the fact that programmable
  components like servlets must include both the logic to generate the dynamic
  code as well as all static elements (such as static content and style). The
  need for a more useful solution soon appeared.</p>

  <p>To fill the gap between Java programmers and web engineers (groups
  that rarely overlap), Sun proposed the Java Server Pages (JSP) specification,
  a markup language (today with both SGML and XML syntax) that allows web
  engineers to include code in their pages, rather than include pages in their
  code. The impact of this strategy was significant: servlets were written
  directly in Java code if very little static content was to be used, otherwise
  JSP or other compiled server pages technologies were used.</p>

  <p>This said, it would seem that using servlets/JSPs to create
  dynamic XML content would be the perfect choice. Unfortunately, design issues
  indicate that we should take a second look at the technology, and understand why
  this isn't so.</p>
</s1>

<s1 title="Servlet Chaining Vs. Servlet Nesting">
  <p>Java Servlets were introduced by the Java Web Server team as a
  way to allow users to create their own <em>web plug-ins</em>. They were designed
  to handle the HTTP protocol and all possible dynamic web content (including
  HTML, XML, images, etc. - both text and binary streams). Unfortunately, the need
  for a componentized request handler was not taken into serious consideration
  in the design phase but only later, when at an implementation phase.</p>

  <p>In fact, the Java Web Server provided the ability to <em>chain</em>
  multiple servlets, one becoming the filter of the other. Unfortunately, since
  the API doesn't include such a possibility in its design, such a servlet chain is
  very limited in its behavior and puts significant restrictions on the API use.
  Something that forced the Servlet API architects to come up with better
  solutions.</p>

  <p>The solution was <em>servlet nesting</em>: the ability for a servlet to
  include another servlet's output inside its own transparently. This allowed
  programmers to separate different logic on different servlets, thus removing
  the need for servlet chaining.</p>
</s1>

<s1 title="The limitations of Servlet Nesting">
  <p>While servlet nesting was a major advantage over servlet
  chaining because it allowed servlets to be somewhat modular without losing
  the full API power, a common design pattern applies to the Servlet model in
  general: no servlet is allowed to modify the output of another servlet. This
  holds true for all servlet API versions up to today (version 2.2).</p>

  <p>This limitation is the key: if no further XML processing is
  needed on the server side, using servlets/JSP for creating XML is a perfect
  choice, but if this output requires some server side processing (for example
  XSLT transformations), the Servlet API does not allow another servlet to
  post-process it's output. This other servlet is, in our case, Cocoon.</p>

  <p>In a few words, the Servlet API doesn't support <em>Servlet
  Piping</em>.</p>
</s1>

<s1 title="The Cocoon Model">
  <p>Rather than turning Cocoon into a servlet engine, thus
  limiting its portability, this document outlines some solutions that allow
  Cocoon users to get the servlet-equivalent functionality with internal Cocoon
  design ideas.</p>

  <p>The Cocoon processing model is based on the separation of</p>

  <dl>
    <dt>Production</dt>
    <dd>where XML content is generated based on Request parameters
     (servlet equivalent)</dd>
    <dt>Processing</dt>
    <dd>where the produced XML content is transformed/evaluated</dd>
    <dt>Formatting</dt>
    <dd>where the XML content is finally formatted into the desired output format
     for client use.</dd>
  </dl>

  <p>This separation of working contexts allows Cocoon users to
  implement their own internal modules to add the functionality they require to
  the whole publishing system. In fact, while a few of these components are
  already shipped with Cocoon, the highly modular structure allows you to build
  your own to fit your particular needs.</p>
</s1>

<s1 title="Writing Producers">
  <p>Producers initiate the request handling phase. They are
  responsible for evaluating the HttpServletRequest parameters provided and create
  XML content that is fed into the processing reactor. Servlet logic should be
  translated into a producer if the request parameters can be used directly to
  generate the XML content (for example the FileProducer which loads the
  requested file from disk).</p>

  <p>Here follows the code for an example producer distributed with
  Cocoon:</p>

<source><![CDATA[
public class DummyProducer
  extends AbstractProducer
  implements Status
{

  String dummy = "<?xml version=\"1.0\"?>"
      + "<?cocoon-format type=\"text/html\"?>"
      + "<html><body>"
      + "<h1 align=\"center\">"
          + "Hello from a dummy page"
      + "</h1>"
      + "</body></html>";

  public Reader getStream(HttpServletRequest request)
    throws IOException
  {
    return new StringReader(dummy);
  }

  public String getPath(HttpServletRequest request) {
    return "";
  }

  public String getStatus() {
    return "Dummy Producer";
  }
}
]]></source>

  <p>The key method is <code>getStream()</code> which is responsible for
  processing the given servlet request and provide a Reader for reading the
  generated XML document.</p>

  <p>Note that AbstractProducer has also another method,
  <code>getDocument(request)</code>, which is responsible for directly returning a
  DOM tree. In case you need to render your servlet code Cocoon-aware, the above
  example should tell you what to do.</p>

  <p>Please look at the shipped producers' source code for example
  code and look at the <connect href="guide.xml">user guide</connect> for how to
  install and use your own producers.</p>
</s1>

<s1 title="Writing Processors">
  <p>If your servlet needs many parameters to work, it is more
  reasonable that you write a Processor instead. A Processor transforms a given
  XML document (which, in this case should contain the needed static parameters)
  into something else, driven both by the input document and by the request
  object which is also available.</p>

  <p>Here is a simple processor example that should show you what
  the above means. Suppose you have the following document as input (note that
  it may have been produced from a file, from other sources or dynamically - see
  the above paragraph):</p>

<source><![CDATA[
<?xml version="1.0"?>
<page>
 <p>Current time is <time/></p>
</page>
]]></source>

  <p>Our simple example processor will look for the &lt;time/&gt; tags and will
  expand them to the current local time, creating this result document:</p>

<source><![CDATA[
<?xml version="1.0"?>
<page>
 <p>Current time is 6:48PM</p>
</page>
]]></source>

  <p>Please look at the shipped processors' source code for example
  code and look at the <connect href="guide.xml">user guide</connect> for how to
  install and use your own processors.</p>
</s1>

<s1 title="Using Cocoon processors">
  <p>The above example shows a very simple situation but needs
  non-trivial code to implement it. For this reason, the Cocoon distribution
  includes a number of processors that implement common needs and situations.
  These are:</p>

  <dl>
    <dt>The XSLT processor</dt>
    <dd>
      Applies XSLT
      transformations to the input document. XSLT allows you to solve your
      transformation needs as well as simple tag evaluation/processing due to
      its extensible and programmable nature. XSLT is a W3C Recommendation.
    </dd>
    <dt>The XSP processor</dt>
    <dd>
      Evaluates XSP pages and compiles them into
      producers. This processor allows you include programmatic logic into
      your pages as well as to separate the logic from the content. See the
      <connect href="xsp-primer.xml">XSP user guide</connect> for more information.
      Note that the XSP Processor assumes that it is getting its input from a static
      file, so it will not work well with pre-processing. Its design means that
      it should really have been a Producer in the first place, instead of
      a Processor. This change has been made in Cocoon 2.
    </dd>
    <dt>The DCP processor (Deprecated)</dt>
    <dd>
      Evaluates XML processing
      instructions with multi-language (Java and EcmaScript) logic. This
      processor allows you to do programmatic substitution and inclusion
      eliminating the need for complex processing logic. See the <connect href="dcpprocessor.xml">DCP
      user guide</connect> for more information. Note: This is deprecated -
      users are advised to use the more powerful
      <connect href="xsp-primer.xml">XSP processor</connect> instead.
    </dd>
    <dt>The SQL processor (Deprecated)</dt>
    <dd>
      Evaluates simple tags
      describing SQL queries to JDBC drivers and formats their result-set in XML
      depending on given parameters. See the <connect href="sqlprocessor.xml">SQL
      processor user guide</connect> for more information. Note: This is deprecated -
      users are advised to use the
      <connect href="sqltaglib.xml">XSP SQL taglib</connect>, or the more
      powerful <connect href="esql.xml">Extended SQL taglib</connect> instead.
      The latter (ESQL taglib) allows easy post-processing of output within XSP,
      amongst other things, whilst the former taglib is mainly provided for backward
      compatability.
    </dd>
    <dt>The LDAP processor</dt>
    <dd>
      the <em>LDAP</em> processor that evaluates simple tags
      describing LDAP queries to directory services and formats their result-set in XML
      depending on given parameters. See the <connect href="ldapprocessor.xml">LDAP
      processor user guide</connect> for more information.
    </dd>
  </dl>
</s1>
</body></document>