<?xml version="1.0"?>
<!DOCTYPE document SYSTEM "./dtd/document-v10.dtd">
<document>
 <header>
  <title>How Cocoon engine works</title>
  <version>Thu Aug 24 16:38:14</version>
  <authors>
   <person name="Luca Ida Giovanni Toldo" email="lucatoldo@aol.com"/>
  </authors>
 </header>
<body>
 <s1 title="How Cocoon 1.7.4. works">
  <p>
  From hereafter and unless otherwise specified, for sake of brevity any class name
is assumed to be prepended the <code>org.apache.cocoon</code> prefix. The description hereafter tries to follow the operations of Cocoon from a &quot; document point of view &quot; while the <code>javadoc</code> documentation describes it from a &quot; procedural point of view&quot;. Therefore, this documentation tries to be complementary to the <code>javadoc</code> one and not to repeat parts therein. Furthermore, since the ultimate documentation is the <code>code</code> itself, this document tries not to go too deep but eventually integrates the comments in the code.
  </p>
  </s1>
  
  <s1 title="Cocoon">
   <p>
   This is the &quot;main&quot; class either at commandline use or from the
   servlet environment. Clearly, it contains the methods <code>init</code>
   for the first case as well as <code>main</code> for the latter case.
   </p>
   <p>
   Hereafter are described the operations in the two common cases of commandline (
typical for initial debugging and software development) and in servlet environment.
   </p>
    <s2 title="from the commandline">
    <p>
       When <code>Cocoon</code> is invoked from the commandline, it requires the information for the location of the <code>cocoon.properties</code> and then the name of the file containing the information to be processed. Upon loading of the properties,
it creates a new <code>EngineWrapper</code> initialized with the above mentioned properties and then handles to it <code>output</code> as well as <code>input</code> streams.
    </p>
     <s3 title="EngineWrapper">
      <p>
       This is a &quot;dirty hack&quot; implemented in order to wrap methods that allow the engine to be called from commandline.The code &quot;is a hack&quot; since it tries to work around the problem that servlet API <em>are not that easy to deal when you enter other modes of operation</em>. Likely, when the code will be adopt <code>Stylebook</code>, this class will as well be cleaned up.
      </p>
      <p>
       Basically, this class instantiates a <code>Engine</code> class and handles to it the <code>output</code> as well as <code>input</code> streams.
      </p>
     </s3>
    </s2>
    <s2 title="from the servlet">
     <s3 title="startup phase">
      <p>
       As any well behaving servlet, upon startup the <code>init</code> method is invocated, which upon successful load of configuration information creates the <code>Engine</code>
      </p>
     </s3>
     <s3 title="production phase">
     <p>
      According to the servlet specification, a <code>service</code> method is as-well provided by this <code>Class</code>. This method is the one which is called by the servlet (e.g. Tomcat) and gets both the <code>HttpServletRequest</code> as wellas will return (to the servlet, e.g. to Tomcat) the <code>HttpServletResponse</code>. Basically, what happens is that the
     </p>
     </s3>
   </s2>
  </s1>
  
  <s1 title="Engine" >
   <source>This class implements the engine that does all the document processing.</source>
   <p>
   What a better definition of the function of this class than the words of its Author (Stefano Mazzocchi) ? From this otherwise lapidary definition, one should realize the importance of this Class in the context of the Cocoon operations and thus carefuly read should be performed and thorough understanding of it be assured.
   </p>
   <s2 title="startup phase">
    <p>
    Either from commandline or from the servlet, upon startup of the cocoon servlet the <code>Engine</code> is instantiated by the <code>private Engine</code> method. For the sake of understanding the Cocoon operations, it is important to know that at this point in time (and only this time in the whole lifespan of the Cocoon servlet) the objects performing the initialization of the various components 
    </p>
     <ul>
      <li><code>Parser</code></li>
   
     </ul> 
    <p>are instantiated with the parameters contained by the Configuration object. This is the reason why if changes are applied to the cocoon.properties file, these cannot be exploited by the Cocoon engine unless the engine is stopped and restarted.</p>
   </s2>
   <s2 title="production phase">
    <p>
    The <code>handle</code> method has been already mentioned previously and is indeed the main actor of the runtime operations of Cocoon. It gets invocated with two handles, one for the input <code>HttpServletRequest</code> and one for the output <code>HttpServletResponse</code>.
    </p>
    <p>Until the whole page is done, it</p>
     <ol>
      <li>Create the <code>Page</code> wrapper</li>
      <li>Gets the document <code>Producer</code> from the <code>ProducerFactory</code> matching the request</li>
      <li>Generate a <code>org.w3c.dom.Document</code> from the input stream</li>
      <li>Setup the hash table environment to pass the parameters to the processor pipeline</li>
      <li>Process the document through the document <code>Processor</code>s, for each processor invoked in the <code>Document</code> and matched in the <code>ProcessorFactory</code></li>
      <li>Get the <code>Formatter</code> requested by the <code>Document</code> and matching the <code>FormatterFactory</code></li>
      <li>Format the page</li>
      <li>Fill the page bean with content</li>
      <li>Set the content type and the encoding</li>
     </ol>
     <p>Finally,</p>
     <ul>
       <li>Set the content type of the response</li>
       <li>Setup the output writer</li>
       <li>Print the page to the PrintWriter object</li>
       <li>Append processsing information sas XML comment, if the content type allows</li>
       <li>Flush the PrinterWriter to the user</li>
       <li>Cache the page</li>
     </ul>
    <p>
     Now I suggest you to take a deep breath and read again the above steps since
this is so beautiful the simplicity of the algorithm exploited that it make sense to appreciate i tin depth and breath.
    </p>
   </s2>
   <p>
    At this point the key elements are therefore the processors and the formatters, which directly operate upon the content of the Document. We are going to investigate them in detail. Should be already clear that indeed one can have more than one <code>Processor</code> in one <code>Document</code> and that these are going to be applied sequentially one on top of the previous. Namely, this is how is implemented the &quot;chaining&quot; of various <code>Processors</code>: in five lines of code (including debugging information). Again, simplicity and good coding style are assets of this implementation. Let us have a look then at what <code>Processors</code> and <code>Formatters</code> are, since these could be leveraged further and indeed these are going to be likely extended with new components for specific needs .
   </p>
  </s1>
  
  <s1 title="ProducerFactory">
  <p>
  For each source there must be an appropriate Producer implemented. Currently (version 1.7.4) the following ones are implemented:
  </p>
   <ul>
    <li>from File</li>
    <li>from HttpServletRequest</li>
   </ul>
  <p>Certainly one could think of more producer types, such as CORBA, RMI, SMTP, etc..</p>
  </s1>

  <s1 title="ProcessorFactory">
   <p>
   For each processing instruction type  there must be an appropriate Processor implemented. Currently (version 1.7.4) the following ones are implemented:
   </p>
    <ul>
     <li>Light weight Directory Access Protocol</li>
     <li>SQL</li>
     <li>eXtendible Server Pages (superseeds Dynamic Content Processor)</li> 
     <li>Dynamic Content Processor (deprecated, useXSP  instead)</li>
     <li>xinclude</li>
     <li>xslt</li>
    </ul>
  </s1>

  <s1 title="FormatterFactory">
   <p>
   For each format in which the output should be delivered (e.g. PDF, TEXT, HTML, XML, XHTML ), there must be an appropriate Formatter implemented. Currently (version 1.7.4 ) the following ones are distributed:
   </p>
   <ul>
    <li>FO2PDF</li>
    <li>HTML</li>
    <li>Text</li>
    <li>XHTML</li>
    <li>XML</li>
   </ul>
    <p>
    Clearly, one might imagine of many more formats such as
   </p>
   <ul>
     <li>FO2RTF Microsoft Rich Text Format</li>
     <li>FO2MIF FrameMaker Interchange Format</li>
     <li>BRAILLE</li>
   </ul>
   <p>
     Could be noticed that the "FO" processing required both for FO2RTF as well as FO2MIF might be skipped
     would one express the content in a format which does not implies formatting in the same page layout
     semantic as for the printed medium. Infact, VoiceXML is supported by Cocoon by simply returning XML
     and indeed in that case the processing instruction cocoon format is <code>text/xml</code> ! In the
     case of VRML, the cocoon format is <code>model/vrml</code> which in the <code>cocoon.properties</code>
     configuration file is &quot;mapped&quot; to <code>TextFormatter</code>
   </p>
   <p>
    Recent discussions in the the Cocoon mailing list have raised further interest on the latter topic which seems as well to be well designed for being implemented in decentralized way. Therefore hereafter is further analyzed how the <code>FormatterFactory</code> works and what needs to be done to implement new <code>Formatter</code> classes in a way that can be easily integrated in Cocoon 1.7.4
   </p>
   <p>
    Due to the empyrical nature of the operations, we will follow a couple of examples of growing complexity in order to identify common programming paradigms and coding patterns which could then be used as guidelines for further formatters.
   </p>
  <s2 title="XMLFormatter">
   <p>
    Likely the easiest of the tasks, since is mostly a &quot;pass-through&quot; method. Its tasks are:
   </p>
   <ul>
    <li>set the MIME type= &quot;text/xml/quot;</li>
    <li>pass the XML through, leaving the XML declarations an dusing the XML method</li>
   </ul>
   <p>
  The <code>format</code> method is implemented by simply making use of 
<code>org.apache.xml.serialize.SerializerFactory</code> 
   </p>   
  </s2>
  <s2 title="TextFormatter">
   <p>Another simple implementation of a Formatter, as stated in the code notes from the Author (Stefano Mazzocchi, surprised?)</p>
   <source>This formatter is used to serialize non-marked-up results such as plain text outputs, VRML, CSS etc.</source>
   <p>Its biggest tasks are:</p>
   <ul>
    <li>set the MIMEtype= &quot;text/plain&quot;</li>
    <li>convert the XML to text, removing the XML declarations and using TEXT method</li>
   </ul>
  </s2>

   <s2 title="HTMLFormatter">
    <p>
    Here the difficult task of mapping between XML and HTML tags is exploited as above by the SerializerFactory methods and thus is simply passed through to that. Very little coding as well. Mostly focused on:
    </p>
    <ul>
     <li>set the MIMEtype=&quot;text/html&quot;</li>
     <li>convert XML to HTML, removing the XML declaration and using HTML method</li>
    </ul>
   </s2>

   <s2 title="FO2PDFFormatter">
    <p>
    Certainly the most complex of the Formatters so far implemented. It does not make use of the
SerializerFactory but instead of PDFRenderer from the FOP engine. 
    </p>
    <ul>
     <li>set the MIME type=&quot;application/pdf&quot;</li>
     <li>instantiate a new org.apache.fop.apps.Driver class</li>
     <li>follow the example use of such class by setting the Writer to the cocoon's writer and then feeding the buildFooTree with the DOM</li>
    </ul>
   </s2>

  </s1>

</body>
</document>
