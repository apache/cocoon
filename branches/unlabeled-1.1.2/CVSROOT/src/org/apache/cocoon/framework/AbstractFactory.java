/*****************************************************************************
 * Copyright (C) 1999 The Apache Software Foundation.   All rights reserved. *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1,  a copy of wich has been included  with this distribution in *
 * the LICENSE file.                                                         *
 *****************************************************************************/
package org.apache.cocoon.framework;

/**
 * The <code>AbstractFactory</code> object is configurable implementation of
 * an object factory.
 *
 * @author <a href="mailto:fumagalli@exoffice.com">Pierpaolo Fumagalli</a>, 
 *         Exoffice Technologies, INC.</a>
 * @author Copyright 1999 &copy; <a href="http://www.apache.org">The Apache
 *         Software Foundation</a>. All rights reserved.
 * @version CVS $Revision: 1.1.2.1 $ $Date: 2000-02-07 15:35:38 $
 * @since Cocoon 2.0
 */
public abstract class AbstractFactory implements Configurable {
    /** The class of the objects generated by this factory */
    private Class currentClass=null;
    /** The configurations of this factory */
    private Configurations configurations=null;

    /**
     * Create a new instance of this AbstractFactory.
     */
    public AbstractFactory() {
        super();
    }

    /**
     * Return the Class to wich the objects produced by this factory are
     * to be casted to.
     * <br>
     * This is used during configuration to check wether the objects produced
     * by this factory will be assignable to the class returned by this
     * method.
     */
    public abstract String getAssignableClassName();

    /**
     * Return the Configurations object used to configure this factory.
     */
    public Configurations getFactoryConfigurations() {
        return(this.configurations);
    }

    /**
     * Create a new instance of the class specified at configuration.
     *
     * @exception RuntimeException It should NEVER happen, since the factory
     *                             tries to instantiate the class at
     *                             configuration time, but it's better than
     *                             returning a null.
     */
    public Object createInstance()
    throws ConfigurationException {
        String c=this.currentClass.getName();
        try {
            return(this.currentClass.newInstance());
        } catch (IllegalAccessException e) {
            throw this.newException("Can't access class '"+c+"'",e);
        } catch (InstantiationException e) {
            throw this.newException("Can't instantiate class '"+c+"'",e);
        } catch (Exception e) {
            throw this.newException("Error trying to load and/or instantiate '"+
                                    c+"'",e);
        }            
    }

    /**
     * Configure this AbstractFactory.
     * <br>
     * The &quot;className&quot; parameter is used to specify what objects
     * are produced by this factory.
     */
    public void configure(Configurations conf)
    throws ConfigurationException {
        // Store configurations
        this.configurations=conf;
        // Retrieve the class name of the objects to create.
        String c=conf.getParameter("className");
        if (c==null)
            throw this.newException("Parameter 'className' not specified");
        // Try to load the class
        this.currentClass=this.loadClass(c);
        // Check if the class is assignable from the one we want
        Class assignable=this.loadClass(this.getAssignableClassName());
        if (!assignable.isAssignableFrom(this.currentClass))
            throw this.newException("Specified class '"+assignable.getName()+
                                    "' is not assignable from '"+
                                    this.currentClass.getName()+"'");
        // Try to do an instantiation (to check, just in case)
        Object temp=this.createInstance();
        // Everything should be fine now
    }

    /** Load a class */
    private Class loadClass(String name)
    throws ConfigurationException {
        try {
            return(Class.forName(name));
        } catch (ClassNotFoundException e) {
            throw this.newException("Factory cannot load class "+name);
        }
    }
    
    /** Create a ConfigurationException */
    private ConfigurationException newException(String msg) {
        return(this.newException(msg,null));
    }

    /** Create a ConfigurationException */
    private ConfigurationException newException(String msg, Exception exc) {
        return(new ConfigurationException(msg,exc,this.getClass()));
    }
}   
