<?xml version="1.0"?>

<!-- =============== Cocoon Sitemap Working Draft ============================

 Copyright (C) 2000 The Apache Software Foundation. All rights reserved.
 
 Redistribution of this document is permitted provided that the following 
 conditions are met:
 
 1. Redistributions must retain the above copyright notice,
    this list of conditions and the following disclaimer.
 
 2. This document is referred to and considered only as "working draft".
 
 3. Any software implementation inspired by this document must indicate
    in its documentation: 

     "inspired by research and development on behalf of the 
      Apache Software Foundation"
 
 4. The names "Cocoon" and  "Apache Software Foundation"  must not be used to
    endorse  or promote  products inspired  from this  document without  prior
    written permission. For written permission, please contact
    apache@apache.org.
 
 5. Products  derived from this document may not  be called "Cocoon", nor may
    "Cocoon" nor "Apache" appear in their name, without prior written 
    permission  of the Apache Software Foundation.
 
 THIS DOCUMENT IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS  FOR A PARTICULAR  PURPOSE ARE  DISCLAIMED.  IN NO  EVENT SHALL  THE
 APACHE SOFTWARE  FOUNDATION  OR ITS CONTRIBUTORS  BE LIABLE FOR  ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLU-
 DING, BUT NOT LIMITED TO, PROCUREMENT  OF SUBSTITUTE GOODS OR SERVICES; LOSS
 OF USE, DATA, OR  PROFITS; OR BUSINESS  INTERRUPTION)  HOWEVER CAUSED AND ON
 ANY  THEORY OF LIABILITY,  WHETHER  IN CONTRACT,  STRICT LIABILITY,  OR TORT
 (INCLUDING  NEGLIGENCE OR  OTHERWISE) ARISING IN  ANY WAY OUT OF THE  USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 This document  consists of voluntary contributions made  by many individuals
 on  behalf of the Apache Software  Foundation. For more information on the 
 Apache Software Foundation, please see <http://www.apache.org/>.

==============================================================================

This document contains an example used as a working draft for 
Cocoon architects to test and understand the issues associated with 
sitemaps and XML publishing in general. It must be considered as a working 
draft and may be updated at any time.

This document is based on ideas and design patterns inspired by Stefano 
Mazzocchi (stefano@apache.org) and Pierpaolo Fumagalli (pier@apache.org)
but grew as a collaborative effort to provide a solid foundation of
design patterns and usability guidelines to create a solid foundation
of sitemap programmability and usability to the Cocoon Publishing 
Framework.

This is one of the few examples where open source is transformed into
"open development" leading both the implementation and the pure research
around software development and usability.

The goal of the sitemap is to allow non-programmers to create web sites
and web applications built from logic components and XML documents.

It finds inspiration from both Apache's httpd.conf/.htaccess files as well
as from Servlet API 2.2 WAR archives. It uses concepts such as Cascading
from W3C CSS, as well as declarative approaches integrated into the W3C 
XSLT language. It also uses some element/attribute equivalence patterns 
used in W3C RDF.

The following goals were identified as engineering constraints:

1) minimal verbosity is of maximum importance.
2) the schema should be sufficiently expressive to allow learning by
examples.
3) sitemap authoring should not require assistive tools, but be
sufficiently future-compatible to allow them.
4) sitemaps must scale along with the site and should not impose growth
limitation to the site as a whole nor limit its administration with size
increase.
5) sitemaps should contain all the information required to Cocoon to
generate all the requests it receives.
6) sitemaps should contain information for both dynamic operation as
well as offline generation.
7) uri mapping should be powerful enough to allow every possible mapping
need.
8) basic web-serving functionalities (redirection, error pages,
resource authorisation) should be provided.
9) sitemaps should not limit Cocoon's intrinsic modular extensibility.
10) resources must be matched with all possible state variables, not
only with URI (http parameters, enviornment variables, server
parameters, time, etc...).
11) sitemaps should embed the notion of "semantic resources" to be
future-compatible with sematic crawling and indexing.
12) sitemaps should be flexible enough to allow a complete web site to
be built with Cocoon.

======================================================================= -->

<!-- 

  The default namespaces are used mainly for versioning, instead of using 
  attributes such as version="1.0" which could create confusion. People are 
  used to writing URIs with no spelling mistakes, while versioning could be 
  used for their own sitemap versions and this might break operation.
  
  The versioning schema will be "major.minor" where major will be increased
  by one each time a new release breaks back compatibility, while minor
  is increased each time a change has been made that doesn't create
  back incompatible problems.

 -->
 
<!--
   
  NOTE (SM)
    
  the syntax
    
      <xxx map:value="yyy">
      
  is completely equivalent to
    
      <xxx>yyy</xxx>
      
  throughout the entire sitemap.. the "value" attribute is a reserved one.
    
  [XXX] (SM) should we use the "map" namespace for this special attribute?
      
-->

<map:sitemap xmlns:map="http://xml.apache.org/cocoon/sitemap/1.0">

<!-- =========================== Components ================================ --> 

 <map:components>

   <!-- 
       Generators generate XML content as SAX events and initialize the 
       pipeline processing. 
   -->
  <map:generators default="parser">
   <map:generator type="parser" src="class://org.apache.cocoon.generator.FileGenerator"/>
   <map:generator type="dir"    src="file:///home/mystuff/java/MyDirGenerator.class"/>
   <map:generator type="xsp"    src="class://org.apache.cocoon.generators.XSPGenerator">
    ...
   </map:generator>
  </map:generators>

   <!-- 
       Filters transform SAX events in SAX events.
   -->
  <map:filters default="xslt">
   <map:filter type="xslt" src="class://org.apache.cocoon.filter.XSLTFilter">
    <compile-stylesheets value="true"/>
   </map:filter>
   <map:filter type="xinclude" src="class://org.apache.cocoon.filter.XIncludeFilter"/>
  </map:filters>

   <!-- 
       Serializers transform SAX events in binary or char streams for 
       final client consumption.
   -->
  <map:serializers default="html">
   <map:serializer type="html" mime-type="text/html" src="class://org.apache.cocoon.serializer.HTMLSerializer">
    <doctype-public value="-//W3C//DTD HTML 4.0 Transitional//EN"/>
    <doctype-system value="http://www.w3.org/TR/REC-html40/loose.dtd"/>
    <preserve-space value="true"/>
    <encoding value="UTF-8"/>
    <indent value="1"/>
    <line-width value="120"/>
   </map:serializer>

   <map:serializer type="wap" mime-type="text/vnd.wap.wml" src="class://org.apache.cocoon.serializer.XMLSerializer">
    <doctype-public>-//WAPFORUM//DTD WML 1.1//EN</doctype-public>
    <doctype-system>http://www.wapforum.org/DTD/wml_1.1.xml</doctype-system>
    <encoding>UTF-8</encoding>
   </map:serializer>

   <map:serializer type="svg2jpg" mime-type="image/jpg" src="class://org.apache.cocoon.serializer.SVGSerializer">
    <format value="jpg"/>
    <compression-level>80%</compression-level>
   </map:serializer>

   <map:serializer type="svg2png" mime-type="image/png" src="class://org.apache.cocoon.serializer.SVGSerializer">
    <format>png</format>
    <color-depth value="24"/>
   </map:serializer>
  </map:serializers>
  
   <!-- 
       Choosers are classes that contain programming logic that perform
       boolean evaluation based on enviornment state during the call (state
       includes request parameters, machine state as well as any other
       accessible information)
       
       Choosers can only respond with true/false when called.
   -->
  <map:choosers default="browser">
   <map:chooser type="load" src="class://org.apache.cocoon.chooser.MachineLoadChooser">
    ...
   </map:chooser>

   <map:chooser type="user" src="class://org.apache.cocoon.chooser.AuthenticationChooser">
    ...
   </map:chooser>

   <map:chooser type="browser" src="class://org.apache.cocoon.matcher.BrowserChooser">
    ...
   </map:chooser>
  </map:choosers>

   <!-- 
       Matchers are classes that are able to test if the request parameters
       match the given pattern and, if this is the case, they are able to 
       return a collection of tokens that resulted from the matching or any
       depending on the matcher own logic (this is up to the matcher implementation).
   -->
  <map:matchers default="uri-wildcard">
   <map:matcher type="uri-wildcard" src="class://org.apache.cocoon.matcher.WildcardURIMatcher">
    ...
   </matcher>

   <map:matcher type="uri-regexp" src="class://org.apache.cocoon.matcher.RegexpURIMatcher">
    ...
   </map:matcher>
  </map:matcher>

 </map:components>

<!-- =========================== Resources ================================= --> 

 <!-- 
     the <resource> element is used as a placeholder for pipelines
     that are used several times inside the document. This element
     is redundant and its functionality is not directly related
     to the sitemap, but could be cloned by the use of internal
     XInclude, for example
   
         <xinclude:include href="#xpointer(resource[@name='Access refused'])"/>
   
     but given the usability constraints and very specific operation
     it is much easier to include such an element instead of forcing
     the use of xinclude/xpointer.
 -->
 <map:resources>
  
  <map:resource name="Access refused">
   <map:generator type="parser" src:local="./error-pages/restricted.xml"/>
   <map:filter type="xslt" src:local="./stylesheets/general-browser.xsl"/>
   <map:serializer type="html" status-code="401"/>
  </map:resource>
    
 </map:resources>
 
<!-- =========================== Sitemap =================================== --> 

 <!-- 
     Mount points allow sitemaps to be cascaded and site management 
     workload to be parallelized.
   -->
 <map:match pattern="cocoon/*">
  <map:mount src="cvs:pserver:anonymous@xml.apache.org://home/cvs/cocoon/xdocs/{1}"/>
 </map:match>

 <map:match pattern="bugs/*">
  <map:mount src="jar://apps/bugs.cocoon#{1}"/>
 </map:match>

 <map:match pattern="dist/*">
  <map:mount src="./dist/{1}"/>
 </map:match>

 <map:match pattern="faq/*">
  <map:mount src="jar://apps/faq-o-matic.cocoon#{1}"/>
 </map:match>

 <map:match type="uri-regexp" pattern="^/xerces-(j|c|p)/(.*)$">
  <map:mount src="cvs:pserver:anonymous@xml.apache.org://home/cvs/xerces-{1}/xdocs/{2}"/>
 </map:match>
 
 <!-- 
      Matchers declarative dispatch the requests to the pipelines that
      match some of their parameters
   -->
 <map:match pattern="cocoon/dist/*"> 
  <map:choose type="ip-filter">
   <map:when test="allowsAddress()">
    <!-- 
        the <redirect> element is used to redirect one requested URI 
        to another. This is somewhat equivalent to URI rewriting.
      -->
    <map:redirect to="dist/cocoon/{1}"/>
   </map:when>
   <map:otherwise>
    <map:resource name="Access refused"/>
   </map:otherwise>
  </map:choose>
 </map:match>

 <!-- 
      When no "type" attribute is present, the sitemap intepreter will use the
      default one, this allows a very compact and user friendly syntax as the
      one below 
   -->
 <map:match pattern="printer-friendly/*">
  <map:generate src:local="{1}.xml"/>
  <map:filter src:local="./stylesheet/printer-friendly.xsl"/>
  <map:serialize/>
 </map:match>

 <map:match pattern="images/logo">
  <map:choose>
   <map:when test="accepts('image/svg')">
    <!-- 
       the <read> element is used to read the src directly without 
       applying any processing. This is mostly useful when clients
       are capable of handling XML content directly.
      -->
    <map:read src="./images/logo.svg"/>
   </map:when>
   <map:otherwise>
    <map:generate src="./images/logo.svg"/>
    <map:choose>
     <map:when test="accepts('image/png')">
      <map:serialize type="svg2png"/>
     </map:when>
     <map:otherwise>
      <map:serialize type="svg2jpg"/>
     </map:otherwise>
    </map:choose>
   </map:otherwise>
  </map:choose>
 </map:match>

 <map:match pattern="restricted/*">
  <map:choose type="user">
   <map:when test="is('administrator')">
    <map:generate src="./restricted/{1}"/>
    <map:filter src="./stylesheets/restricted.xsl"/>
    <map:serialize/>
   </map:when>
   <map:otherwise>
    <map:resource name="Access refused"/>
   </map:otherwise>
  </map:choose>
 </map:match>

 <!--
     Complex example to show how some xpath-like syntax is used to get access
     to the pattern tokens generated by the matchers.
   -->
 <map:match pattern="nested-matchers/*">
  <map:match type="browser" pattern="name('Mozilla ?\?*')">
   <map:mount src="file:///home/www/mozilla-{1}-{2}/{../1}"/>
  </map:match>
 </map:match>

 <map:match pattern="complex-semantics/*">

  <!--
      The semantic view should contain all the information that semantic
      crawlers need to fully understand this resource. It normally means
      that RDF, XLink and PI are contained in this view of the resource
      and Cocoon will be able to interrupt the pipeline at this point
      if the client is requesting this.
        
      This will be used for offline crawlers, metadata indexers and
      XML-capable browsers.
  -->
        
  <!-- NOTE (SM)
     
      The semantic-view element might become too specific if the new 
      CC/PP (http://www.w3.org/TR/CCPP-ra/) user-agent capabilities
      architecture proposal is implemented. If this happens, the need for
      multiple pipeline exit points depending on the requestor capabilities
      will emerge. But this is clearly _way_ too early to expect, anyway...
           
  -->
  
  <map:view type="semantic">
   <map:generate src="./complex-semantics/{1}"/>
   <map:filter src="./stylesheet/rdf-izer.xsl"/>
   <map:filter src="./stylesheet/xlink-izer.xsl"/>
  </map:view>
  

  <map:choose>
   <map:when test="accepts('text/vnd.wap.wml')">
    <map:filter src="./stylesheet/rdf2wml.xsl"/>
    <map:serialize type="wap"/>
   </map:when>
   <map:otherwise>
    <map:filter src="./stylesheet/rdf2html.xsl"/>
    <map:serialize/>
   </map:otherwise>
  </map:choose>
 </map:match>

 <map:match type="uri-regexp" pattern="/\([0-9]\{4\}\)/\([0-9]\{2\}\)/\([0-9]\{2\}\)/">
  <!--
       Here we implement the ability to indicate semantic information
       on the processed URI. This is mostly used to avoid to encode
       URI specific information in the XSP since the sitemap maintainer
       is the only one responsible to manage the URI space. This removes
       a URI contract between the XSP writer and the URI space manager, 
       moving it to parameter names which normally change less frequently.
  -->
  <map:param name="year" value="{1}"/>
  <map:param name="month" value="{2}"/>
  <map:param name="day" value="{3}"/>
  
  <map:generator name="serverpages" src="./dailynews.xsp"/>
  <map:filter src="./stylesheet/{1}/news.xsl"/>
  <map:serializer/>
 </map:match>

 <map:match pattern="*">
  <map:generate src:local="{1}.xml"/>
  <map:choose type="load">
   <map:when test="greaterThen('2.5')">
    <map:filter src"./stylesheet/low-graphics.xsl"/>
   </map:when>
   <map:otherwise>
    <choose>
     <map:when test="is('Mozilla5')">
      <map:filter src="./stylesheet/xul-enabled.xsl"/>
     </map:when>
     <map:otherwise>
      <map:filter src="./stylesheet/general-browser.xsl"/>
     </map:otherwise>
    </map:choose>
   </map:otherwise>
  </map:choose>
  <map:serializer/>
 </map:match>
    
</map:sitemap>

<<<<<<< sitemap-working-draft.xmap
<!-- end of file -->

=======
<!-- end of file -->
>>>>>>> 1.1.2.2
