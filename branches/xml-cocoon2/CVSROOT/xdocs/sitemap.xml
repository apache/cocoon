<?xml version="1.0" encoding="ISO-8859-1" ?>

<!DOCTYPE document SYSTEM "./dtd/document-v10.dtd">

<document>
 <header>
  <title>The Sitemap</title>
  <authors>
   <person name="Giacomo Pati" email="Giacomo.Pati@pwr.ch"/>
   <person name="Stefano Mazzocchi" email="stefano@apache.org"/>
  </authors>
 </header>

 <body>

  <s1 title="The Sitemap">
   <p>
    This document is used as a working draft for 
    Cocoon architects to understand the issues associated with 
    sitemaps and XML publishing in general. It must be considered as a working 
    draft and may be updated at any time.
   </p>

   <p>
    This document is based on ideas and design patterns inspired by Stefano 
    Mazzocchi (stefano@apache.org) and Pierpaolo Fumagalli (pier@apache.org)
    but grew as a collaborative effort to provide a solid foundation of
    design patterns and usability guidelines to create a solid foundation
    of sitemap programmability and usability to the Cocoon Publishing 
    Framework.
   </p>

   <p>
    This is one of the few examples where open source is transformed into
    "open development" leading both the implementation and the pure research
    around software development and usability.
   </p>

   <p>
    The goal of the sitemap is to allow non-programmers to create web sites
    and web applications built from logic components and XML documents.
   </p>

   <p>
    It finds inspiration from both Apache's httpd.conf/.htaccess files as well
    as from Servlet API 2.2 WAR archives. It uses concepts such as Cascading
    from W3C CSS, as well as declarative approaches integrated into the W3C 
    XSLT language. It also uses some element/attribute equivalence patterns 
    used in W3C RDF.
   </p>

   <p>
    The following goals were identified as engineering constraints:
   </p>

   <ol>
    <li>minimal verbosity is of maximum importance.</li>
    <li>the schema should be sufficiently expressive to allow learning by
     examples.</li>
    <li>sitemap authoring should not require assistive tools, but be
     sufficiently future-compatible to allow them.</li>
    <li>sitemaps must scale along with the site and should not impose growth
     limitation to the site as a whole nor limit its administration with size
     increase.</li>
    <li>sitemaps should contain all the information required to Cocoon to
     generate all the requests it receives.</li>
    <li>sitemaps should contain information for both dynamic operation as
     well as offline generation.</li>
    <li>uri mapping should be powerful enough to allow every possible mapping
     need.</li>
    <li>basic web-serving functionalities (redirection, error pages,
     resource authorisation) should be provided.</li>
    <li>sitemaps should not limit Cocoon's intrinsic modular extensibility.</li>
    <li>resources must be matched with all possible state variables, not
     only with URI (http parameters, enviornment variables, server
     parameters, time, etc...).</li>
    <li>sitemaps should embed the notion of "semantic resources" to be
     future-compatible with sematic crawling and indexing.</li>
    <li>sitemaps should be flexible enough to allow a complete web site to
     be built with Cocoon.</li>
   </ol>

   <s2 title="The Structure">
    <p>
     The Sitemap has the following general structure:
    </p>
  
    <source>
     <![CDATA[
      <map:sitemap xmlns:map="http://xml.apache.org/cocoon/sitemap/1.0">
       <map:components/>
       <map:resources/>
       <map:match/>
       <map:match/>
        ...
       <map:match/>
      </map:sitemap>
     ]]>
    </source>
   </s2>

   <s2 title="The &lt;map:sitemap&gt;">
    <source>
     <![CDATA[
      <map:sitemap xmlns:map="http://xml.apache.org/cocoon/sitemap/1.0">
     ]]>
    </source>

    <p>
     The default namespaces are used mainly for versioning, instead of using 
     attributes such as version="1.0" which could create confusion. People are 
     used to writing URIs with no spelling mistakes, while versioning could be 
     used for their own sitemap versions and this might break operation.
    </p>

    <p>  
     The versioning schema will be "major.minor" where major will be increased
     by one each time a new release breaks back compatibility, while minor
     is increased each time a change has been made that doesn't create
     back incompatible problems.
    </p>
   </s2>

   <s2 title="The &lt;map:components&gt;">
    <source>
     <![CDATA[
      <map:components">
       <map:generators/>
       <map:filters/>
       <map:serializers/>
       <map:choosers/>
       <map:matchers/>
      </map:components">
     ]]>
    </source>

    <s3 title="Common Attributes of Components">
     <p>
      All components have some common attributes. The list below will show and explain them:
     </p>

     <dl>
      <dt>type</dt>
      <dd>The type attribute gives the component a reference which can be used to point to them in the pipeline section.</dd>
      <dt>src</dt>
      <dd>Specifies where Cocoon finds the class representing this component. Note that the content of 
       the src attribute must be specified as an URI. 
      </dd>
     </dl>

     <p>
      The following protocols can be specified for all URI aware attributes:
     </p>
     <ul>
      <li>file:</li>
      <li>class:</li>
      <li>jar:</li>
      <li>http:</li>
     </ul>
    </s3>

    <s3 title="Component Parameters">
     <p>
      All components will be configured with parameters specified from their child elements at component instantiation time. 
      The name of the parameters is dependant of the component. The following example shows how to specify a
      <code>&lt;compile-stylesheet&gt;</code> parameters to a component:
     </p>
  
     <source>
      <![CDATA[
       <map:components>
        <map:filter type="xslt" src="class:///org.apache.cocoon.filter.XSLTFilter">
         <compile-stylesheets value="true"/>  <!-- This is a parameter to the filter component -->
        </map:filter>
       </map:components>
      ]]>
     </source>
 
     <note>
      The syntax <br/> <br/>
       <strong><code>&lt;xxx map:value="yyy"&gt;</code></strong> <br/> <br/>
      is completely equivalent to <br/> <br/>
       <strong><code>&lt;xxx&gt;yyy&lt;/xxx&gt;</code></strong> <br/> <br/>
       throughout the entire sitemap.. the "value" attribute is a reserved one.
     </note>
  
     <p>
      There is no given set of predefined parameters.
     </p>
    </s3>

    <s3 title="Generators">
     <p>
      A <jump anchor="interface-generator"><code>Generator</code></jump> generates XML content as SAX events and initialize the 
      pipeline processing. 
     </p>

     <source>
      <![CDATA[
       <map:generators default="parser">
        <map:generator type="parser" src="class:///org.apache.cocoon.generator.FileGenerator"/>
        <map:generator type="dir"    src="file:///home/mystuff/java/MyDirGenerator.class"/>
        <map:generator type="xsp"    src="class:///org.apache.cocoon.generators.XSPGenerator">
         ...
        </map:generator>
       </map:generators>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:generators&gt;</code> specifies the type 
      of generator to use if none is specified in a pipeline.
     </p>
   
    </s3>

    <s3 title="Filters">
     <p>
      A <jump anchor="interface-filter"><code>Filter</code></jump> transform SAX events in SAX events.
     </p>

     <source>
      <![CDATA[
       <map:filters default="xslt">
        <map:filter type="xslt" src="class:///org.apache.cocoon.filter.XSLTFilter">
         <compile-stylesheets value="true"/>
        </map:filter>
        <map:filter type="xinclude" src="class:///org.apache.cocoon.filter.XIncludeFilter"/>
       </map:filters>
      ]]>
     </source>


     <p>
      The <code>default</code> attribute on <code>&lt;map:filters&gt;</code> specifies the type 
      of filter to use if none is specified in a pipeline.
     </p>
    </s3>

    <s3 title="Serializers">
     <p>
      A <jump anchor="interface-serializer"><code>Serializers</code></jump> transform SAX events 
      in binary or char streams for final client consumption.
     </p>

     <source>
      <![CDATA[
       <map:serializers default="html">
        <map:serializer type="html" mime-type="text/html" 
          src="class:///org.apache.cocoon.serializer.HTMLSerializer">
         <doctype-public value="-//W3C//DTD HTML 4.0 Transitional//EN"/>
         <doctype-system value="http://www.w3.org/TR/REC-html40/loose.dtd"/>
         <preserve-space value="true"/>
         <encoding value="UTF-8"/>
         <indent value="1"/>
         <line-width value="120"/>
        </map:serializer>

        <map:serializer type="wap" mime-type="text/vnd.wap.wml" 
          src="class:///org.apache.cocoon.serializer.XMLSerializer">
         <doctype-public>-//WAPFORUM//DTD WML 1.1//EN</doctype-public>
         <doctype-system>http://www.wapforum.org/DTD/wml_1.1.xml</doctype-system>
         <encoding>UTF-8</encoding>
        </map:serializer>

        <map:serializer type="svg2jpg" mime-type="image/jpg" 
          src="class:///org.apache.cocoon.serializer.SVGSerializer">
         <format value="jpg"/>
         <compression-level>80%</compression-level>
        </map:serializer>

        <map:serializer type="svg2png" mime-type="image/png" 
          src="class:///org.apache.cocoon.serializer.SVGSerializer">
         <format>png</format>
         <color-depth value="24"/>
        </map:serializer>
       </map:serializers>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:serializers&gt;</code> specifies the type 
      of serializer to use if none is specified in a pipeline.
     </p>
    </s3>

    <s3 title="Choosers">
     <p>
      A <jump anchor="interface-chooser"><code>Chooser</code></jump> evaluate a boolean expression.
     </p>
     <source>
      <![CDATA[
       <map:choosers default="browser">
        <map:chooser type="load" src="class:///org.apache.cocoon.chooser.MachineLoadChooser">
         ...
        </map:chooser>

        <map:chooser type="user" src="class:///org.apache.cocoon.chooser.AuthenticationChooser">
         ...
        </map:chooser>

        <map:chooser type="browser" factory="class:///org.apache.cocoon.matcher.BrowserChooserFactory">
         ...
        </map:chooser>
       </map:choosers>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:choosers&gt;</code> specifies the type 
      of chooser to use if none is specified in a pipeline.
     </p>

     <p> 
      Because the sitemap will be translated and compiled into a java class at runtime a 
      <jump anchor="interface-chooser"><code>Chooser</code></jump> can specify a attribute <code>factory</code>
      instead of a <code>src</code>. This <jump anchor="interface-chooser-factory"><code>ChooserFactory</code></jump>
      class must be capable to return a java source code fragment that can be embedded into a method corresponding 
      to the <jump anchor="interface-chooser"><code>Chooser</code></jump>s evaluate method.
     </p>
    </s3>

    <s3 title="Matchers">
     <p>
      A <jump anchor="interface-matcher"><code>Matcher</code></jump> maps a pattern to a resource.
     </p>
     <source>
      <![CDATA[
       <map:matchers default="uri-wildcard">
        <map:matcher type="uri-wildcard" factory="class:///org.apache.cocoon.matcher.WildcardURIMatcherFactory">
         ...
        </map:matcher>

        <map:matcher type="uri-regexp" src="class:///org.apache.cocoon.matcher.RegexpURIMatcher">
         ...
        </map:matcher>
       </map:matchers>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:matchers&gt;</code> specifies the type 
      of matcher to use if none is specified in a pipeline.
     </p>

     <p> 
      Because the sitemap will be translated and compiled into a java class at runtime a 
      <jump anchor="interface-matcher"><code>Matcher</code></jump> can specify a attribute <code>factory</code>
      instead of a <code>src</code>. This <jump anchor="interface-matcher-factory"><code>MatcherFactory</code></jump>
      class must be capable to return a java source code fragment that can be embedded into a method corresponding 
      to the <jump anchor="interface-matcher"><code>Matcher</code></jump>s match method.
     </p>
    </s3>
   </s2>

   <s2 title="The &lt;map:resources&gt;">
    <p>
     The <code>&lt;resource&gt;</code> element is used as a placeholder for pipelines
     that are used several times inside the document. This element
     is redundant and its functionality is not directly related
     to the sitemap, but could be cloned by the use of internal
     XInclude, for example
    </p>
   
    <p>
     <code>&lt;xinclude:include href="#xpointer(resource[@name='Access refused'])"/&gt;</code> 
    </p>
   
    <p>
     but given the usability constraints and very specific operation
     it is much easier to include such an element instead of forcing
     the use of xinclude/xpointer.
    </p>
    <source>
     <![CDATA[
      <map:resources">
      </map:components">
     ]]>
    </source>
 -->
 <map:resources>
  
  <map:resource name="Access refused">
   <map:generator src="./error-pages/restricted.xml"/>
   <map:filter src="./stylesheets/general-browser.xsl"/>
   <map:serializer status-code="401"/>
  </map:resource>
    
 </map:resources>

    <s3 title="Common Attributes of Components">
     <p>
      All components have some common attributes. The list below will show and explain them:
     </p>

     <dl>
      <dt>type</dt>
      <dd>The type attribute gives the component a reference which can be used to point to them in the pipeline section.</dd>
      <dt>src</dt>
      <dd>Specifies where Cocoon finds the class representing this component. Note that the content of 
       the src attribute must be specified as an URI. 
      </dd>
     </dl>

     <p>
      The following protocols can be specified for all URI aware attributes:
     </p>
     <ul>
      <li>file:</li>
      <li>class:</li>
      <li>jar:</li>
      <li>http:</li>
     </ul>
    </s3>

    <s3 title="Component Parameters">
     <p>
      All components will be configured with parameters specified from their child elements at component instantiation time. 
      The name of the parameters is dependant of the component. The following example shows how to specify a
      <code>&lt;compile-stylesheet&gt;</code> parameters to a component:
     </p>
  
     <source>
      <![CDATA[
       <map:components>
        <map:filter type="xslt" src="class:///org.apache.cocoon.filter.XSLTFilter">
         <compile-stylesheets value="true"/>  <!-- This is a parameter to the filter component -->
        </map:filter>
       </map:components>
      ]]>
     </source>
 
     <note>
      The syntax <br/> <br/>
       <strong><code>&lt;xxx map:value="yyy"&gt;</code></strong> <br/> <br/>
      is completely equivalent to <br/> <br/>
       <strong><code>&lt;xxx&gt;yyy&lt;/xxx&gt;</code></strong> <br/> <br/>
       throughout the entire sitemap.. the "value" attribute is a reserved one.
     </note>
  
     <p>
      There is no given set of predefined parameters.
     </p>
    </s3>

    <s3 title="Generators">
     <p>
      Generators generate XML content as SAX events and initialize the 
      pipeline processing. 
     </p>

     <source>
      <![CDATA[
       <map:generators default="parser">
        <map:generator type="parser" src="class:///org.apache.cocoon.generator.FileGenerator"/>
        <map:generator type="dir"    src="file:///home/mystuff/java/MyDirGenerator.class"/>
        <map:generator type="xsp"    src="class:///org.apache.cocoon.generators.XSPGenerator">
         ...
        </map:generator>
       </map:generators>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:generators&gt;</code> specifies the type 
      of generator to use if none is specified in a pipeline.
     </p>
   
    </s3>
   </s2>
  </s1>

  <s1 title="Interface specifications">
   <anchor id="interface-XMLProducer"/>
   <s2 title="XMLProduces">
    <p>
     This interfaces identifies classes that produce XML data, sending SAX
     events to the configured <code>XMLConsumer</code> (or SAX 
     <code>ContentHandler</code> and <code>LexicalHandler</code>).<br/>
     It's beyond the scope of this interface to specify a way in wich the XML
     data production is started.
    </p>

    <source>
     <![CDATA[
      public interface XMLProducer {
          /** Set the <code>XMLConsumer</code> that will receive XML data. */
          public void setConsumer(XMLConsumer consumer);

          /** Set the <code>ContentHandler</code> that will receive XML data. */
          public void setContentHandler(ContentHandler content);

          /** Set the <code>LexicalHandler</code> that will receive XML data. */
          public void setLexicalHandler(LexicalHandler lexical);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-XMLConsumer"/>
   <s2 title="XMLConsumer">
    <p>
     This interfaces identifies classes that consume XML data, receiving 
     notification of SAX events.<br/>
     This interface unites the idea of SAX <code>ContentHandler</code> and
     <code>LexicalHandler</code>.
    </p>

    <source>
     <![CDATA[
      public interface XMLConsumer extends ContentHandler, LexicalHandler {
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-sitemap-component"/>
   <s2 title="SitemapComponent">
    <p>
     Every component in the sitemap must implement the following interface:
    </p>

    <source>
     <![CDATA[
      public interface SitemapComponent extends Component {
          /**
           * Set the <code>Request</code>, <code>Response</code> and sitemap
           * <code>Parameters</code> used to process the request.
           */
          public void setup(Request req, Response res, String src, Parameters par)
                  throws ProcessingException, SAXException, IOException;
          }
     ]]>
    </source>
   </s2>

   <anchor id="interface-generator"/>
   <s2 title="Generator">
    <p>
     A <code>Generator</code> must implement at least the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Generator extends XMLProducer, SitemapComponent {
          public void generate()
                  throws IOException, SAXException, ProcessingException;
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-filter"/>
   <s2 title="Filter">
    <p>
     A <code>Filter</code> must implement at least the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Filter extends XMLProducer, XMLConsumer, SitemapComponent {
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-serializer"/>
   <s2 title="Serializer">
    <p>
     A <code>Serializer</code> gets the <code>OutputStream</code> where the XML should 
     be serialized with the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Serializer extends XMLConsumer, SitemapComponent {

    /**
     * Set the <code>OutputStream</code> where the XML should be serialized.
     */
    public void setOutputStream(OutputStream out);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-chooser"/>
   <s2 title="Chooser">
    <p>
     A <code>Chooser</code> gets a expression to evaluate and signals the evaluation with a 
     boolean value.
    </p>

    <source>
     <![CDATA[
      public interface Chooser implements Component {
          public boolean evaluate(...);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-chooser-factory"/>
   <s2 title="ChooserFactory">
    <p>
     A <code>ChooserFactory</code> is capable to return the java source code of the evaluate method of a
     <jump anchor="interface-chooser"><code>Chooser</code></jump> object. It gets the value of the test 
     attribute from the sitemap.
    </p>

    <source>
     <![CDATA[
      public interface ChooserFactory {
          public String generateCode(String test);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-matcher"/>
   <s2 title="Chooser">
    <p>
     A <code>Matcher</code> gets the <code>OutputStream</code> where the XML should 
     be serialized with the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Matcher implements Component {
          public Map match(...);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-matcher-factory"/>
   <s2 title="MatcherFactory">
    <p>
     A <code>MatcherFactory</code> is capable to return the java source code of the match method of a
     <jump anchor="interface-matcher"><code>Matcher</code></jump> object. It gets the value of the pattern 
     attribute from the sitemap.
    </p>

    <source>
     <![CDATA[
      public interface MatcherFactory {
          public String generateCode(String pattern);
      }
     ]]>
    </source>
   </s2>
  </s1>
 
 </body>
</document>
