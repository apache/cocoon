<?xml version="1.0" encoding="ISO-8859-1" ?>

<!DOCTYPE document SYSTEM "./dtd/document-v10.dtd">

<document>
 <header>
  <title>The Sitemap</title>
  <authors>
   <person name="Giacomo Pati" email="Giacomo.Pati@pwr.ch"/>
   <person name="Stefano Mazzocchi" email="stefano@apache.org"/>
  </authors>
 </header>

 <body>

  <s1 title="The Sitemap">
   <p>
    This document is used as a working draft for 
    Cocoon architects to understand the issues associated with 
    sitemaps and XML publishing in general. It must be considered as a working 
    draft and may be updated at any time.
   </p>

   <p>
    This document is based on ideas and design patterns inspired by Stefano 
    Mazzocchi (stefano@apache.org) and Pierpaolo Fumagalli (pier@apache.org)
    but grew as a collaborative effort to provide a solid foundation of
    design patterns and usability guidelines to create a solid foundation
    of sitemap programmability and usability to the Cocoon Publishing 
    Framework.
   </p>

   <p>
    This is one of the few examples where open source is transformed into
    "open development" leading both the implementation and the pure research
    around software development and usability.
   </p>

   <p>
    The goal of the sitemap is to allow non-programmers to create web sites
    and web applications built from logic components and XML documents.
   </p>

   <p>
    It finds inspiration from both Apache's httpd.conf/.htaccess files as well
    as from Servlet API 2.2 WAR archives. It uses concepts such as Cascading
    from W3C CSS, as well as declarative approaches integrated into the W3C 
    XSLT language. It also uses some element/attribute equivalence patterns 
    used in W3C RDF.
   </p>

   <p>
    The following goals were identified as engineering constraints:
   </p>

   <ol>
    <li>minimal verbosity is of maximum importance.</li>
    <li>the schema should be sufficiently expressive to allow learning by
     examples.</li>
    <li>sitemap authoring should not require assistive tools, but be
     sufficiently future-compatible to allow them.</li>
    <li>sitemaps must scale along with the site and should not impose growth
     limitation to the site as a whole nor limit its administration with size
     increase.</li>
    <li>sitemaps should contain all the information required to Cocoon to
     generate all the requests it receives.</li>
    <li>sitemaps should contain information for both dynamic operation as
     well as offline generation.</li>
    <li>uri mapping should be powerful enough to allow every possible mapping
     need.</li>
    <li>basic web-serving functionalities (redirection, error pages,
     resource authorisation) should be provided.</li>
    <li>sitemaps should not limit Cocoon's intrinsic modular extensibility.</li>
    <li>resources must be matched with all possible state variables, not
     only with URI (http parameters, enviornment variables, server
     parameters, time, etc...).</li>
    <li>sitemaps should embed the notion of "semantic resources" to be
     future-compatible with sematic crawling and indexing.</li>
    <li>sitemaps should be flexible enough to allow a complete web site to
     be built with Cocoon.</li>
   </ol>

   <s2 title="The Structure">
    <p>
     The Sitemap has the following general structure:
    </p>
  
    <source>
     <![CDATA[
      <map:sitemap xmlns:map="http://xml.apache.org/cocoon/sitemap/1.0">
       <map:components/>
       <map:resources/>
       <map:match/>
       <map:match/>
        ...
       <map:match/>
      </map:sitemap>
     ]]>
    </source>
   </s2>

   <s2 title="The &lt;map:sitemap&gt;">
    <source>
     <![CDATA[
      <map:sitemap xmlns:map="http://xml.apache.org/cocoon/sitemap/1.0">
     ]]>
    </source>

    <p>
     The default namespaces are used mainly for versioning, instead of using 
     attributes such as version="1.0" which could create confusion. People are 
     used to writing URIs with no spelling mistakes, while versioning could be 
     used for their own sitemap versions and this might break operation.
    </p>

    <p>  
     The versioning schema will be "major.minor" where major will be increased
     by one each time a new release breaks back compatibility, while minor
     is increased each time a change has been made that doesn't create
     back incompatible problems.
    </p>
   </s2>

   <s2 title="The &lt;map:components&gt;">
    <source>
     <![CDATA[
      <map:components">
       <map:generators/>
       <map:transformers/>
       <map:serializers/>
       <map:selectors/>
       <map:matchers/>
      </map:components">
     ]]>
    </source>

    <s3 title="Common Attributes of Components">
     <p>
      All components have some common attributes. The list below will show and explain them:
     </p>

     <dl>
      <dt>type</dt>
      <dd>The type attribute gives the component a reference which can be used to point to them in the pipeline section.</dd>
      <dt>src</dt>
      <dd>Specifies where Cocoon finds the class representing this component. Note that the content of 
       the src attribute must be specified as an URI. 
      </dd>
     </dl>

     <p>
      The following protocols can be specified for all URI aware attributes:
     </p>
     <ul>
      <li>file:</li>
      <li>class:</li>
      <li>jar:</li>
      <li>http:</li>
     </ul>
    </s3>

    <s3 title="Component Parameters">
     <p>
      All components will be configured with parameters specified from their child elements at component instantiation time. 
      The name of the parameters is dependant of the component. The following example shows how to specify a
      <code>&lt;compile-stylesheet&gt;</code> parameters to a component:
     </p>
  
     <source>
      <![CDATA[
       <map:components>
        <map:transformer type="xslt" src="class:///org.apache.cocoon.transformation.XSLTTransformer">
         <compile-stylesheets value="true"/>  <!-- This is a parameter to the transformer component -->
        </map:transformer>
       </map:components>
      ]]>
     </source>
 
     <note>
      The syntax <br/> <br/>
       <strong><code>&lt;xxx map:value="yyy"&gt;</code></strong> <br/> <br/>
      is completely equivalent to <br/> <br/>
       <strong><code>&lt;xxx&gt;yyy&lt;/xxx&gt;</code></strong> <br/> <br/>
       throughout the entire sitemap.. the "value" attribute is a reserved one.
     </note>
  
     <p>
      There is no given set of predefined parameters.
     </p>
    </s3>

    <s3 title="Generators">
     <p>
      A <link href="#interface-generator"><code>Generator</code></link> generates XML content as SAX events and initialize the 
      pipeline processing. 
     </p>

     <source>
      <![CDATA[
       <map:generators default="parser">
        <map:generator type="parser" src="class:///org.apache.cocoon.generator.FileGenerator"/>
        <map:generator type="dir"    src="file:///home/mystuff/java/MyDirGenerator.class"/>
        <map:generator type="xsp"    src="class:///org.apache.cocoon.generators.XSPGenerator">
         ...
        </map:generator>
       </map:generators>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:generators&gt;</code> specifies the type 
      of generator to use if none is specified in a pipeline.
     </p>
   
    </s3>

    <s3 title="Transformers">
     <p>
      A <link href="#interface-transformer"><code>Transformer</code></link> transform SAX events in SAX events.
     </p>

     <source>
      <![CDATA[
       <map:transformers default="xslt">
        <map:transformer type="xslt" src="class:///org.apache.cocoon.transformation.XSLTTransformer">
         <compile-stylesheets value="true"/>
        </map:transformer>
        <map:transformer type="xinclude" src="class:///org.apache.cocoon.transformation.XIncludeTransformer"/>
       </map:transformers>
      ]]>
     </source>


     <p>
      The <code>default</code> attribute on <code>&lt;map:transformers&gt;</code> specifies the type 
      of transformer to use if none is specified in a pipeline.
     </p>
    </s3>

    <s3 title="Serializers">
     <p>
      A <link href="#interface-serializer"><code>Serializers</code></link> transform SAX events 
      in binary or char streams for final client consumption.
     </p>

     <source>
      <![CDATA[
       <map:serializers default="html">
        <map:serializer type="html" mime-type="text/html" 
          src="class:///org.apache.cocoon.serializer.HTMLSerializer">
         <doctype-public value="-//W3C//DTD HTML 4.0 Transitional//EN"/>
         <doctype-system value="http://www.w3.org/TR/REC-html40/loose.dtd"/>
         <preserve-space value="true"/>
         <encoding value="UTF-8"/>
         <indent value="1"/>
         <line-width value="120"/>
        </map:serializer>

        <map:serializer type="wap" mime-type="text/vnd.wap.wml" 
          src="class:///org.apache.cocoon.serializer.XMLSerializer">
         <doctype-public>-//WAPFORUM//DTD WML 1.1//EN</doctype-public>
         <doctype-system>http://www.wapforum.org/DTD/wml_1.1.xml</doctype-system>
         <encoding>UTF-8</encoding>
        </map:serializer>

        <map:serializer type="svg2jpeg" mime-type="image/jpeg" 
          src="class:///org.apache.cocoon.serializer.SVGSerializer">
        </map:serializer>

        <map:serializer type="svg2png" mime-type="image/png" 
          src="class:///org.apache.cocoon.serializer.SVGSerializer">
        </map:serializer>
       </map:serializers>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:serializers&gt;</code> specifies the type 
      of serializer to use if none is specified in a pipeline.
     </p>
    </s3>

    <s3 title="Selectors">
     <p>
      A <link href="#interface-selector"><code>Selector</code></link> evaluate a boolean expression.
     </p>
     <source>
      <![CDATA[
       <map:selectors default="browser">
        <map:selector type="load" src="class:///org.apache.cocoon.selection.MachineLoadSelector">
         ...
        </map:selector>

        <map:selector type="user" src="class:///org.apache.cocoon.selection.AuthenticationSelector">
         ...
        </map:selector>

        <map:selector type="browser" factory="class:///org.apache.cocoon.selection.BrowserSelectorFactory">
         ...
        </map:selection>
       </map:selection>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:selectors&gt;</code> specifies the type 
      of selector to use if none is specified in a pipeline.
     </p>

     <p> 
      Because the sitemap will be translated and compiled into a java class at runtime a 
      <link href="#interface-selector"><code>Selector</code></link> can specify a attribute <code>factory</code>
      instead of a <code>src</code>. This <link href="#interface-code-factory"><code>CodeFactory</code></link>
      class must be capable to return a java source code fragment that can be embedded into a method corresponding 
      to the <link href="#interface-selector"><code>Selector</code></link>s evaluate method.
     </p>
    </s3>

    <s3 title="Matchers">
     <p>
      A <link href="#interface-matcher"><code>Matcher</code></link> maps a pattern to a resource.
     </p>
     <source>
      <![CDATA[
       <map:matchers default="uri-wildcard">
        <map:matcher type="uri-wildcard" factory="class:///org.apache.cocoon.matcher.WildcardURIMatcherFactory">
         ...
        </map:matcher>

        <map:matcher type="uri-regexp" src="class:///org.apache.cocoon.matcher.RegexpURIMatcher">
         ...
        </map:matcher>
       </map:matchers>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:matchers&gt;</code> specifies the type 
      of matcher to use if none is specified in a pipeline.
     </p>

     <p> 
      Because the sitemap will be translated and compiled into a java class at runtime a 
      <link href="#interface-matcher"><code>Matcher</code></link> can specify a attribute <code>factory</code>
      instead of a <code>src</code>. This <link href="#interface-matcher-factory"><code>MatcherFactory</code></link>
      class must be capable to return a java source code fragment that can be embedded into a method corresponding 
      to the <link href="#interface-matcher"><code>Matcher</code></link>s match method.
     </p>
    </s3>
   </s2>

   <s2 title="The &lt;map:resources&gt;">
    <p>
     The <code>&lt;resource&gt;</code> element is used as a placeholder for pipelines
     that are used several times inside the document. This element
     is redundant and its functionality is not directly related
     to the sitemap, but could be cloned by the use of internal
     XInclude, for example
    </p>
   
    <p>
     <code>&lt;xinclude:include href="#xpointer(resource[@name='Access refused'])"/&gt;</code> 
    </p>
   
    <p>
     but given the usability constraints and very specific operation
     it is much easier to include such an element instead of forcing
     the use of xinclude/xpointer.
    </p>
    <source>
     <![CDATA[
      <map:resources>
       <map:resource name="Access refused">
        <map:generate src="./error-pages/restricted.xml"/>
        <map:transform src="./stylesheets/general-browser.xsl"/>
        <map:serialize status-code="401"/>
       </map:resource>
      </map:resources>
     ]]>
    </source>

    <s3 title="Common Attributes of Components">
     <p>
      All components have some common attributes. The list below will show and explain them:
     </p>

     <dl>
      <dt>type</dt>
      <dd>The type attribute gives the component a reference which can be used to point to them in the pipeline section.</dd>
      <dt>src</dt>
      <dd>Specifies where Cocoon finds the class representing this component. Note that the content of 
       the src attribute must be specified as an URI. 
      </dd>
     </dl>

     <p>
      The following protocols can be specified for all URI aware attributes:
     </p>
     <ul>
      <li>file:</li>
      <li>class:</li>
      <li>jar:</li>
      <li>http:</li>
     </ul>
    </s3>

    <s3 title="Component Parameters">
     <p>
      All components will be configured with parameters specified from their child elements at component instantiation time. 
      The name of the parameters is dependant of the component. The following example shows how to specify a
      <code>&lt;compile-stylesheet&gt;</code> parameters to a component:
     </p>
  
     <source>
      <![CDATA[
       <map:components>
        <map:transformer type="xslt" src="class:///org.apache.cocoon.transformation.XSLTTransformer">
         <compile-stylesheets value="true"/>  <!-- This is a parameter to the transformer component -->
        </map:transformer>
       </map:components>
      ]]>
     </source>
 
     <note>
      The syntax <br/> <br/>
       <strong><code>&lt;xxx map:value="yyy"&gt;</code></strong> <br/> <br/>
      is completely equivalent to <br/> <br/>
       <strong><code>&lt;xxx&gt;yyy&lt;/xxx&gt;</code></strong> <br/> <br/>
       throughout the entire sitemap.. the "value" attribute is a reserved one.
     </note>
  
     <p>
      There is no given set of predefined parameters.
     </p>
    </s3>

    <s3 title="Generators">
     <p>
      Generators generate XML content as SAX events and initialize the 
      pipeline processing. 
     </p>

     <source>
      <![CDATA[
       <map:generators default="parser">
        <map:generator type="parser" src="class:///org.apache.cocoon.generator.FileGenerator"/>
        <map:generator type="dir"    src="file:///home/mystuff/java/MyDirGenerator.class"/>
        <map:generator type="xsp"    src="class:///org.apache.cocoon.generators.XSPGenerator">
         ...
        </map:generator>
       </map:generators>
      ]]>
     </source>

     <p>
      The <code>default</code> attribute on <code>&lt;map:generators&gt;</code> specifies the type 
      of generator to use if none is specified in a pipeline.
     </p>
   
    </s3>
   </s2>
  </s1>
 
  <s1 title="Pipelines">
    <s2 title="Mounting sitemaps">
     <s3 title="Introduction">
    <p>
       Mount points allow sitemaps to be cascaded and site management
       workload to be parallelized. This creates a tree of sitemaps with
       the main sitemap at the root and possibly several subsitemaps
       as nodes and leaves.
     </p>
     <p>The subsitemaps serve two important goals: scalability and
      simplification of maintainance. The different subsitemaps are indepent
      and don't affect each other.
    </p>
     <source>
<![CDATA[
   <map:match pattern="faq/*"> 
    <map:mount uri-prefix="faq/" check-reload="no" src="faq/sitemap.xmap"/> 
   </map:match> 
]]>
    </source>
    <p>
     The src attribute is where the subsitemap is located. If it ends in a slash
     "sitemap.xmap" is appended to find the sitemap otherwise the src
     value is used. A check-reload attribute can be used to determine if the
     modification date of the subsitemap file should be checked. 
     The uri-prefix is the part that should be removed from the request URI.
     The engine will correctly check for a trailing slash (which you may
     write, of course).
     If in the example above "faq/cocoon" is requested, "faq/" is removed from
     the URI and "cocoon" is passed to the subsitemap which is loaded
     from "faq/sitemap.xmap".
     </p>
     <p>
     Sitemap components (generators, transformers, etc.) in a sitemap are accessible 
     by a sub-sitemap by their names. This is due to the fact that each sitemap has its 
     own SitemapComponentManager and they are arranged in the same hierarchical 
     structure as the sitemaps are and thus knows which are their parent 
     SitemapComponentManager and can ask it for a SitemapComponent it doesn't know about.
     </p>
    </s3>
    <s3 title="Usage Cases">
    <p>
     Usually you use the same SitemapComponents over and over again in your sub-sitemaps. 
     And because you have a contract between the parent and sub sitemaps (the uri-prefix) you 
     can deliver common SitemapComponents from the parent sitemap to your sub-sitemaps as well.
     If you break a sitemap all its sub-sitemaps are broken as well (because of the hierarchical arragement).
     </p>
     <p>
     However you can create independant subsitemaps, which meet the following goals:
     </p>
     <ol>
      <li>Simplify site construction</li>
      <li>Reduce risk of "bad' sitemap entries killing whole site</li>
      <li>Ease deployment of pre-built applications</li>
      <li>Keep sitemap files an understandable and manageable size</li>
     </ol>
     <p>
     Just build a main sitemap with the minimum needs: A matcher and a selector. 
     These two components allow to select and direct to mount two other sitemaps.
     These sub-sitemaps load the componants they need (which includes generators
     and transformers etc...) and have the map elements for that site/application.
     The benefit is that each sitemap is completely independant of each other and
     any error in that sitemap does not kill any other sitemap. 
     </p>
     <p>
     Here is an example of a main sitemap. You will notice that it  is using a selector that
     matches on host name of the request, but any matcher or selector would work
     at this point. Both sub-sitemaps are mounted at the root level.
     </p>
<source>
<![CDATA[
     <?xml version="1.0"?> 
      <map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">
      <!-- =========================== Components
       ================================ -->
    <map:components>
     <map:matchers default="wildcard">
      <map:matcher name="wildcard" factory="org.apache.cocoon.matching.WildcardURIMatcherFactory"/>
     </map:matchers>
 
    <map:selectors default="host">
     <map:selector name="host" factory="org.apache.cocoon.selection.HostSelectorFactory">
        <host name="fee" value="www.foo.com"/>
     </map:selector>
   </map:selectors>
 
   </map:components>
   <!-- =========================== Pipelines
    ================================= -->
    <map:pipelines>
     <map:pipeline>
 
      <map:select type="host">
         <map:when test="fee">
            <map:mount uri-prefix="" src="fee.xmap"/>
        </map:when>
        <map:otherwise>
            <map:mount uri-prefix="" src="foo.xmap"/>
        </map:otherwise>
     </map:select>
 
     </map:pipeline>
   </map:pipelines>
 </map:sitemap>
]]>
    </source>
     </s3>
    </s2>
  </s1>

  <s1 title="Interface specifications">
   <anchor id="interface-XMLProducer"/>
   <s2 title="XMLProduces">
    <p>
     This interfaces identifies classes that produce XML data, sending SAX
     events to the configured <code>XMLConsumer</code> (or SAX 
     <code>ContentHandler</code> and <code>LexicalHandler</code>).<br/>
     It's beyond the scope of this interface to specify a way in wich the XML
     data production is started.
    </p>

    <source>
     <![CDATA[
      public interface XMLProducer {
          /** Set the <code>XMLConsumer</code> that will receive XML data. */
          public void setConsumer(XMLConsumer consumer);

          /** Set the <code>ContentHandler</code> that will receive XML data. */
          public void setContentHandler(ContentHandler content);

          /** Set the <code>LexicalHandler</code> that will receive XML data. */
          public void setLexicalHandler(LexicalHandler lexical);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-XMLConsumer"/>
   <s2 title="XMLConsumer">
    <p>
     This interfaces identifies classes that consume XML data, receiving 
     notification of SAX events.<br/>
     This interface unites the idea of SAX <code>ContentHandler</code> and
     <code>LexicalHandler</code>.
    </p>

    <source>
     <![CDATA[
      public interface XMLConsumer extends ContentHandler, LexicalHandler {
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-sitemap-component"/>
   <s2 title="SitemapComponent">
    <p>
     Every component in the sitemap must implement the following interface:
    </p>

    <source>
     <![CDATA[
      public interface SitemapComponent extends Component {
          /**
           * Set the <code>Request</code>, <code>Response</code> and sitemap
           * <code>Parameters</code> used to process the request.
           */
          public void setup(Request req, Response res, String src, Parameters par)
                  throws ProcessingException, SAXException, IOException;
          }
     ]]>
    </source>
   </s2>

   <anchor id="interface-generator"/>
   <s2 title="Generator">
    <p>
     A <code>Generator</code> must implement at least the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Generator extends XMLProducer, SitemapComponent {
          public void generate()
                  throws IOException, SAXException, ProcessingException;
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-transformer"/>
   <s2 title="Transformer">
    <p>
     A <code>Transformer</code> must implement at least the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Transformer extends XMLProducer, XMLConsumer, SitemapModelComponent {
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-serializer"/>
   <s2 title="Serializer">
    <p>
     A <code>Serializer</code> gets the <code>OutputStream</code> where the XML should 
     be serialized with the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Serializer extends XMLConsumer, SitemapComponent {

    /**
     * Set the <code>OutputStream</code> where the XML should be serialized.
     */
    public void setOutputStream(OutputStream out);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-selector"/>
   <s2 title="Selector">
    <p>
     A <code>Selector</code> gets a expression to evaluate and signals the evaluation with a 
     boolean value.
    </p>

    <source>
     <![CDATA[
      public interface Selector implements Component {
            boolean select (String expression, Map objectModel);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-code-factory"/>
   <s2 title="CodeFactory">
    <p>
     A <code>CodeFactory</code> is capable to return the java source code of the evaluate method of a
     <link href="#interface-selector"><code>Selector</code></link> object. It gets the value of the test 
     attribute from the sitemap.
    </p>

    <source>
     <![CDATA[
      public interface CodeFactory {
            String generateParameterSource (NodeList conf);

            String generateClassSource (String prefix, String test, NodeList conf);

            String generateMethodSource (NodeList conf);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-matcher"/>
   <s2 title="Matcher">
    <p>
     A <code>Matcher</code> gets the <code>OutputStream</code> where the XML should 
     be serialized with the following interface:
    </p>

    <source>
     <![CDATA[
      public interface Matcher implements Component {
          public Map match(...);
      }
     ]]>
    </source>
   </s2>

   <anchor id="interface-matcher-factory"/>
   <s2 title="MatcherFactory">
    <p>
     A <code>MatcherFactory</code> is capable to return the java source code of the match method of a
     <link href="#interface-matcher"><code>Matcher</code></link> object. It gets the value of the pattern 
     attribute from the sitemap.
    </p>

    <source>
     <![CDATA[
      public interface MatcherFactory {
          public String generateCode(String pattern);
      }
     ]]>
    </source>
   </s2>
  </s1>
 
 </body>
</document>
