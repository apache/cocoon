<?xml version="1.0"?>

<!-- =============== Cocoon Sitemap Working Draft ============================

 Copyright (C) 2000 The Apache Software Foundation. All rights reserved.
 
 Redistribution of this document is permitted provided that the following 
 conditions are met:
 
 1. Redistributions must retain the above copyright notice,
    this list of conditions and the following disclaimer.
 
 2. This document is referred to and considered only as "working draft".
 
 3. Any software implementation inspired by this document must indicate
    in its documentation: 

     "inspired by research and development on behalf of the 
      Apache Software foundation"
 
 4. The names "Cocoon" and  "Apache Software Foundation"  must not be used to
    endorse  or promote  products inspired  from this  document without  prior
    written permission. For written permission, please contact
    apache@apache.org.
 
 5. Products  derived from this document may not  be called "Cocoon", nor may
    "Cocoon" nor "Apache" appear in their name, without prior written 
    permission  of the Apache Software Foundation.
 
 THIS DOCUMENT IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS  FOR A PARTICULAR  PURPOSE ARE  DISCLAIMED.  IN NO  EVENT SHALL  THE
 APACHE SOFTWARE  FOUNDATION  OR ITS CONTRIBUTORS  BE LIABLE FOR  ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLU-
 DING, BUT NOT LIMITED TO, PROCUREMENT  OF SUBSTITUTE GOODS OR SERVICES; LOSS
 OF USE, DATA, OR  PROFITS; OR BUSINESS  INTERRUPTION)  HOWEVER CAUSED AND ON
 ANY  THEORY OF LIABILITY,  WHETHER  IN CONTRACT,  STRICT LIABILITY,  OR TORT
 (INCLUDING  NEGLIGENCE OR  OTHERWISE) ARISING IN  ANY WAY OUT OF THE  USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 This document  consists of voluntary contributions made  by many individuals
 on  behalf of the Apache Software  Foundation. For more information on the 
 Apache Software Foundation, please see <http://www.apache.org/>.

==============================================================================

This docuemnt contains an example used as a working draft for 
Cocoon architects to test and understand the issues associated with 
sitemaps and XML publishing in general. It must be considered as a working 
draft and may be updated at any time.

This document is based on ideas and design patterns inspired by Stefano 
Mazzocchi (stefano@apache.org) and Pierpaolo Fumagalli (pier@apache.org)
but grew as a collaborative effort to provide a solid foundation of
design patterns and usability guidelines to create a solid foundation
of sitemap programmability and usability to the Cocoon Publishing 
Framework.

This is one of the few examples were open source is transformed into
"open development" leading both the implementation and the pure research
around software development and usability.

The goal of the sitemap is to allow non-programmers to create web sites
and web applications built from logic components and XML documents.

It finds inspiration from both Apache's httpd.conf/.htaccess files as well
as from Servlet API 2.2 WAR archives. It uses concepts such as Cascading
from W3C CSS, as well as declarative approaches integrated into the W3C 
XSLT language. It also uses some element/attribute equivalence patterns 
used in W3C RDF.

The following goals were identified as engineering constraints:

1) minimal verbosity is of maximum importance.
2) the schema should be sufficiently expressive to allow learning by
examples.
3) sitemap authoring should not require assistive tools, but be
sufficiently future-compatible to allow them.
4) sitemaps must scale along with the site and should not impose growth
limitation to the site as a whole nor limit its administration with size
increase.
5) sitemaps should contain all the information required to Cocoon to
generate all the requests it receives.
6) sitemaps should contain information for both dynamic operation as
well as offline generation.
7) uri mapping should be powerful enough to allow every possible mapping
need.
8) basic web-serving functionalities (redirection, error pages,
resource authorisation) should be provided.
9) sitemaps should not limit Cocoon's intrinsic modular extensibility.
10) resources must be matched with all possible state variables, not
only with URI (http parameters, enviornment variables, server
parameters, time, etc...).
11) sitemaps should embed the notion of °semantic resources° to be
future-compatible with sematic crawling and indexing.
12) sitemaps should be flexible enought to allow a complete web site to
be built with Cocoon.

======================================================================= -->

<!-- NOTE (SM)

The default namespace is used mainly for versioning, instead of using 
version="2.0" which could create confusions. People are used to write URIs 
with no spelling mistakes, while versioning could be used for their own 
sitemap versions and this might break operation.

The "src:" namespace is associated with loaders. This implies a schema for
loaders to be maintained by the Cocoon project. While this limits the 
extensibility of the platform, I think that adding <loaders> as components
might be FS since I don't think there will be need for extending loaders
with more frequency than we could do. All useful loaders will be
integrated into our distribution anyway... maybe proprietary loaders? 

[XXX] is the use of such loader schema too strict?

The "local" attribute is used when the resource is _local_ to the
sitemap. This doesn't have an absolute meaning, but depends on the _where_
the sitemap was found. For example, if the root sitemap was found on a
file system, all local resources are interpreted as files and passed
to the "local" loader. While, if the "file" attribute is used, the file
loader is always used. This is mostly important when the sitemap is
found inside compressed archives or loaded with non-standard loading
methods such as CVS, WebDAV or other forms of databases.

[XXX] is this "local" method useful? may create problems?

-->

<cocoon xmlns="http://xml.apache.org/cocoon/config/2.0" xmlns:src="http://xml.apache.org/cocoon/loaders">

 <!-- here should go Cocoon-specific parameters -->

 <sitemap>

  <!-- NOTE (SM)   

  Components are included _inside_ the sitemap to allow cascading. This 
  means that when a sitemap is mounted by another sitemap, components will
  be inherited as they are if no other component with the same type is found.
  Otherwise, if both type, loading attribute and attribute value are the
  same, the parameters are cascaded, which means that params with equal names
  are overloaded, the others are inherited. 

  -->

  <components>

   <!-- 
       These are general components. They do not partecipate directly into XML
       processing but are general logic components that encapsulate particular
       logic used by other components. These can be obtained by all the "Composer"
       instances via the method:

          Component ComponentManager.getComponent(String role)
   -->
   <component role="pool" src:class="org.apache.cocoon.component.DatabasePool">
    <param name="max-connections">10</param>
   </component>

   <component role="thread-pool" src:class="org.apache.cocoon.component.ThreadPool">
    <param name="starting-threads">10</param>
   </component>

   <!-- 
       Generators generate XML content as SAX events and initialize the 
       pipeline processing. 
   -->
   <generator type="parser" src:class="org.apache.cocoon.generator.FileGenerator"/>
   <generator type="dir"    src:file="/home/mystuff/java/MyDirGenerator.class"/>
   <generator type="xsp"    src:class="org.apache.cocoon.generators.XSPGenerator">
    ...
   </generator>

   <!-- 
       Filters transform SAX events in SAX events.
   -->
   <filter type="xslt" src:class="org.apache.cocoon.filter.XSLTFilter"/>
   <filter type="xinclude" src:class="org.apache.cocoon.filter.XIncludeFilter"/>

   <!-- 
       Serializers transform SAX events in binary or char streams for 
       final client consumption.
   -->
   <serializer type="html" mime-type="text/html" src:class="org.apache.cocoon.serializer.HTMLSerializer">
    <param name="doctype-public">-//W3C//DTD HTML 4.0 Transitional//EN</param>
    <param name="doctype-system">http://www.w3.org/TR/REC-html40/loose.dtd</param>
    <param name="preserve-space">true</param>
    <param name="encoding">UTF-8</param>
    <param name="indent">1</param>
    <param name="line-width">120</param>
   </serializer>

   <serializer type="wap" mime-type="text/vnd.wap.wml" src:class="org.apache.cocoon.serializer.XMLSerializer">
    <param name="doctype-public" value="-//WAPFORUM//DTD WML 1.1//EN"/>
    <param name="doctype-system" value="http://www.wapforum.org/DTD/wml_1.1.xml"/>
    <param name="encoding" value="UTF-8"/>
   </serializer>

   <serializer type="svg2jpg" mime-type="image/jpg" src:class="org.apache.cocoon.serializer.SVGSerializer">
    <param name="format" value="jpg"/>
    <param name="compression-level">80%</param>
   </serializer>

   <serializer type="svg2png" mime-type="image/png" src:class="org.apache.cocoon.serializer.SVGSerializer">
    <param name="format" value="png"/>
    <param name="color-depth">24</param>
   </serializer>

   <!-- 
       Matchers are classes that contain programming logic that perform
       matching based on variable contained in the request, in the server state
       or generally based on any information available during the matching evaluation.

       The main matching type, URI matching, is hardcoded into the sitemap schema
       because, by far, the most used. But it was identified as a clear need the
       ability to extend such matching capabilities to "react" on different
       parameters. Matchers are components invoqued at runtime and returning
       a boolean value indicating the class matched the request or not depending
       on internal logic, configuration parameters and current state.
   -->
   <matcher type="browser" src:class="org.apache.cocoon.matcher.BrowserMatcher">
    ...
   </matcher>

   <matcher type="load" src:class="org.apache.cocoon.matcher.MachineLoadMatcher">
    ...
   </matcher>

   <matcher type="user" src:class="org.apache.cocoon.matcher.AuthenticationMatcher">
    ...
   </matcher>

   <matcher type="ip-filter" src:local="./classes/IPValidityMatcher.class">
    ...
   </matcher>

  </components> 

  <!-- NOTE (SM)

  The use of regexp mapping is considered harmful by many but having being used
  for years inside the Apache httpd.conf <Location ..> element, I think we should
  at least match this functionality, but, just like Apache, having "simple" 
  wildcards-based mapping as the default rule.

  For this reason, every "uri" attribute will use the defaul wildcard mapping rule
  if no "rule" is specified. If rule="regexp" is specified, then regexp mapping is
  used.

  [XXX] Should we use '$1' for both rules? or keep wildcard positioning like shown below?
  
  [XXX] Should we use a different namespace for the "rule" attribute, like we did for loaders?

  -->

  <!-- 
      Mount points allow sitemaps to be cascaded and site management workload to be parallelized.
  -->
  <mount uri="^/xerces-[j|c|p]/(.*)$" src:cvs=":pserver:anonymous@xml.apache.org:/home/cvs/xerces-$1/xdocs/$2" rule="regexp"/>
  <mount uri="cocoon/*" src:cvs=":pserver:anonymous@xml.apache.org:/home/cvs/cocoon/xdocs/*"/>
  <mount uri="bugs/*"   src:jar="./apps/bugs.cocoon#*"/>
  <mount uri="faq/*"    src:jar="jar:./apps/faq-o-matic.cocoon#*"/>
  <mount uri="dist/*"   src:local="./dist/*"/>

  <!-- 
      The process element matches a particular URI and performs the resource 
      construction based on the pipeline routing information it contains. Mapping
      rules for <moutn> apply here as well.
  -->
  <process uri="cocoon/dist/*">
   <match type="ip-filter" allowed-address="true">
     <!-- 
          the <redirect> element is used to redirect one requested URI 
          to another. This is somewhat equivalent to URI rewriting
     -->
    <redirect to="dist/cocoon/*"/>
   </match>
   <otherwise>
    <resource name="Access refused"/>
   </otherwise>
  </process>

  <process uri="printer-friendly/*">
   <generate type="parser" src:local="*.xml"/>
   <filter type="xslt" src:local="./stylesheet/printer-friendly.xsl"/>
   <serialize type="html"/>
  </process>

  <process uri="images/logo">
    <match type="browser" accepts="image/svg">
     <!-- 
         the <read> element is used to read the src directly without 
         applying any processing. This is mostly useful when clients
         are capable of handling XML content directly.
     -->
     <read src:local="./images/logo.svg"/>
    </match>
    <otherwise>
     <generate type="parser" src:local="./images/logo.svg"/>
     <match type="browser" accepts="image/png">
      <serialize type="svg2png"/>
     </match>
     <otherwise>
      <serialize type="svg2jpg"/>
     </otherwise>
    </otherwise>
  </process>

  <process uri="restricted/*">
    <match type="user" is="administrator">
     <generate type="parser" src:local="./restricted/*"/>
     <filter type="xslt" src:local="./stylesheets/restricted.xsl"/>
     <serialize type="html"/>
    </match>
    <otherwise>
     <resource name="Access refused"/>
    </otherwise>
  </process>

  <process uri="complex-semantics/*">
    <semantic-source>
     <generate type="parser" src:local="./complex-semantics/*"/>
     <filter type="xslt" src:local="./stylesheet/rdf-izer.xsl"/>
     <filter type="xslt" src:local="./stylesheet/xlink-izer.xsl"/>
    </semantic-source>
    <match type="browser" accepts="text/vnd.wap.wml">
     <filter type="xslt" src:local="./stylesheet/rdf2wml.xsl"/>
     <serialize type="xml"/>
    </match>
    <otherwise>
     <filter type="xslt" src:local="./stylesheet/rdf2html.xsl"/>
     <serialize type="html"/>
    </otherwise>
  </process>

  <process uri="*">
   <generate type="parser" src:local="*.xml"/>
   <match type="load" greater-then="2.5">
    <filter type="xslt" src:local="./stylesheet/low-graphics.xsl"/>
   </match>
   <match type="browser" is="Mozilla5">
    <filter type="xslt" src:local="./stylesheet/xul-enabled.xsl"/>
   </match>
   <otherwise>
    <filter type="xslt" src:local="./stylesheet/general-browser.xsl"/>
   </otherwise>
   <serializer type="html"/>
  </process>

  <!-- NOTE (SM)

  the <resource> element is used as a placeholder for pipelines
  that are used several times inside the document. This element
  is redundant and its functionality is not directly related
  to the sitemap, but could be cloned by the use of internal
  XInclude, for example

      <xinclude:include href="#xpointer(resource[@name='Access refused'])"/>

  but given the usability constraints and very specific operation
  it is much easier to include such an element instead of forcing
  the use of xinclude/xpointer.

  [XXX] is this element useful?

  -->
  <resource name="Access refused">
   <generator type="parser" src:local="./error-pages/restricted.xml"/>
   <filter type="xslt" src:local="./stylesheets/general-browser.xsl"/>
   <serializer type="html" status-code="401"/>
  </resource>

 </sitemap>

</cocoon>

<!-- end of file -->